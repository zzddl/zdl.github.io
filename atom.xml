<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzddl.github.io/zdl.github.io/</id>
    <title>zdl&apos;s blog</title>
    <updated>2020-07-28T03:07:04.638Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzddl.github.io/zdl.github.io/"/>
    <link rel="self" href="https://zzddl.github.io/zdl.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzddl.github.io/zdl.github.io/images/avatar.png</logo>
    <icon>https://zzddl.github.io/zdl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zdl&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[git学习（6）自定义Git]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-6zi-ding-yi-git/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-6zi-ding-yi-git/">
        </link>
        <updated>2020-07-28T02:07:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1可配置项">1.可配置项</h2>
<p>让Git显示颜色，会让命令输出看起来更醒目：</p>
<pre><code>$ git config --global color.ui true
</code></pre>
<h2 id="2忽略特殊文件">2.忽略特殊文件</h2>
<p>​    （1）在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>​    （2）忽略文件的原则</p>
<p>​        	忽略操作系统自动生成的文件，比如缩略图等；</p>
<p>​			忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</p>
<p>​			忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p>
<p>（3）配置好<code>.gitignore</code>后，就是把<code>.gitignore</code>也提交到Git</p>
<p>（4）检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code></p>
<p>（5）有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了，此时可以强制添加（加上-f）</p>
<pre><code>$ git add -f 文件名
</code></pre>
<p>（6）若是<code>.gitignore</code>写的有问题可以用<code>git check-ignore</code>命令检查</p>
<pre><code>$ git check-ignore -v 文件名
</code></pre>
<p>​    （7）小结</p>
<p>​       忽略某些文件时，需要编写<code>.gitignore</code>；</p>
<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>
<h2 id="3配置别名">3.配置别名</h2>
<p>（1）<code>$ git config --global alias.st status</code>可以让st代替status</p>
<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>（2）<code>$ git last</code>可以显示最后一次提交信息</p>
<p>（3）配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>（4）每个仓库的Git配置文件都放在<code>.git/config</code>文件中</p>
<p>（5）别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习（5）标签管理]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-5biao-qian-guan-li/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-5biao-qian-guan-li/">
        </link>
        <updated>2020-07-28T02:06:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建标签">1.创建标签</h2>
<p>（1）首先，切换到需要打标签的分支上</p>
<p>（2）然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签</p>
<p>（3）可以用命令git tag查看所有标签</p>
<p>（4）<code>$ git log --pretty=oneline --abbrev-commit</code>找到commit id 后</p>
<pre><code>$ git tag v0.9 f52c633（v0.9是标签名，f52c633是commit id）`
</code></pre>
<p>（5）标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息</p>
<p>（6）创建带有说明的标签，用-a指定标签名，-m指定说明文字</p>
<pre><code>    $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb
</code></pre>
<p>（7）小结</p>
<p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>
<p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p>命令<code>git tag</code>可以查看所有标签。</p>
<h2 id="2操作标签">2.操作标签</h2>
<p>（1）删除标签</p>
<pre><code>$ git tag -d v0.1
</code></pre>
<p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除</p>
<p>​    （2）要推送某个标签到远程，使用命令git push origin <tagname></p>
<p>​    （3）一次性推送全部尚未推送到远程的本地标签</p>
<pre><code>$ git push origin –tags
</code></pre>
<p>​    （4）若标签已经推送到远程</p>
<p>​       		首先，从本地删除</p>
<pre><code>$ git tag -d v0.9
</code></pre>
<p>​       		然后从远程删除</p>
<pre><code>$ git push origin :refs/tags/v0.9
</code></pre>
<p>​    （5）小结</p>
<p>​        	命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；5</p>
<p>​			命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>​			命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>​			命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习（4）分支管理]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-4fen-zhi-guan-li/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-4fen-zhi-guan-li/">
        </link>
        <updated>2020-07-28T02:05:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建与合并分支">1.创建与合并分支</h2>
<p>（1）HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支<br>
<img src="https://zzddl.github.io/zdl.github.io//post-images/1595902329718.png" alt="" loading="lazy"><br>
（2）当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上<br>
<img src="https://zzddl.github.io/zdl.github.io//post-images/1595902336627.png" alt="" loading="lazy"><br>
dev向前移动的时候，master指向不变。<br>
合并就是master指向dev所指向的。<br>
<img src="https://zzddl.github.io/zdl.github.io//post-images/1595902342976.png" alt="" loading="lazy"><br>
（3）命令：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch <name></p>
<p>切换分支：git checkout <name>或者git switch <name></p>
<p>创建+切换分支：git checkout -b <name>或者git switch -c <name></p>
<p>合并某分支到当前分支：git merge <name></p>
<p>删除分支：git branch -d <name></p>
<h2 id="2解决冲突">2.解决冲突</h2>
<p>（1）发生冲突后的图示：<br>
<img src="https://zzddl.github.io/zdl.github.io//post-images/1595902353205.png" alt="" loading="lazy"><br>
（2）冲突解决后<br>
<img src="https://zzddl.github.io/zdl.github.io//post-images/1595902361532.png" alt="" loading="lazy"><br>
（3）用带参数的git log也可以看到分支合并情况，如：</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit
</code></pre>
<p>（4）最后要删除分支</p>
<p>（5）小结：</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h2 id="3分支管理策略">3.分支管理策略</h2>
<p>（1）</p>
<pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
</code></pre>
<p>​		dev是分支名字，--no-ff表示禁用Fast forward</p>
<p>（2）合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p>（3）退出<code>git log</code>需要输入命令q</p>
<h2 id="4bug分支">4.Bug分支</h2>
<p>（1）Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作（即把未完成的其他分支的工作先保存起来，然后完成其他事后再继续）</p>
<pre><code>$ git stash
</code></pre>
<p>（2）首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支</p>
<pre><code>$ git checkout master

$ git checkout -b bug分支名字
</code></pre>
<p>修复并且提交完成后，切换到master分支，完成合并，然后删除bug分支</p>
<p>（3）保存的工作可以用<code>$ git stash list</code>来查看</p>
<p>（4）Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>​		一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<pre><code>$ git stash apply stash@{0}
</code></pre>
<p>​		另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p>
<p>（5）Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支（在另外一个分支修复相同的bug）</p>
<pre><code>$ git cherry-pick 4c805e2
</code></pre>
<p>（6）小结</p>
<p>​		修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>​		当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>
<p>​		在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h2 id="5feature分支">5.feature分支</h2>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h2 id="6多人协作">6.多人协作</h2>
<p>（1）要查看远程库的信息，用git remote；用git remote -v显示更详细的信息</p>
<p>（2）推送分支</p>
<pre><code>$ git push origin 分支名字
</code></pre>
<p>（3）需要推送的分支：</p>
<p>​		master分支是主分支，因此要时刻与远程同步；</p>
<p>​		dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>​		bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>​		feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>（4）其他人要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支</p>
<pre><code>$ git checkout -b dev origin/dev
</code></pre>
<p>（5）若其他人的最新提交和你试图推送的提交有冲突，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p>
<p>（6）多人协作的工作模式</p>
<p>​		首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
<p>​		如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
<p>​		如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>​		没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
<p>​		如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。</code></p>
<p>（7）小结</p>
<p>​		查看远程库信息，使用<code>git remote -v</code>；</p>
<p>​		本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>​		从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>​		在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>​		建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>​		从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h2 id="7rebase">7.Rebase</h2>
<p>​    （1）rebase操作可以把本地未push的分叉提交历史整理成直线<br>
​    （2）rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习（3）远程仓库]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-3yuan-cheng-cang-ku/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-3yuan-cheng-cang-ku/">
        </link>
        <updated>2020-07-28T02:04:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1添加远程库">1.添加远程库</h2>
<p>（1）关联远程库</p>
<pre><code>$ git remote add origin [git@github.com:zzddl](mailto:git@github.com:zzddl)(用户名字)/learngit.git
</code></pre>
<p>（2）推送本地库的内容到远程库</p>
<pre><code>$ git push -u origin master
</code></pre>
<p>在之后的提交中只需要输入</p>
<pre><code>$ git push origin master
</code></pre>
<p>（3）由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>
<p>（4）当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<pre><code>The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.

RSA key fingerprint is xx.xx.xx.xx.xx.

Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>​		这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<p>​		Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了（这个警告只会出现一次）：</p>
<pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre>
<p>（5）小结</p>
<p>​		要关联一个远程库，使用命令</p>
<pre><code>git remote add origin [git@server-name:path/repo-name.git](mailto:git@server-name:path/repo-name.git)
</code></pre>
<p>​		关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容。</p>
<p>​		此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改</p>
<p>2.从远程库克隆</p>
<p>（1）在创建时，需要勾选Initialize this repository with a README选项</p>
<p>（2）克隆命令</p>
<pre><code>$ git clone [git@github.com:zzddl](mailto:git@github.com:zzddl)(用户名)/gitskills.git
</code></pre>
<p>（3）git支持多种协议，也包括https，但是ssh协议最快.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习（2）时光机穿梭]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-2shi-guang-ji-chuan-suo/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-2shi-guang-ji-chuan-suo/">
        </link>
        <updated>2020-07-28T02:03:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1版本回退">1.版本回退</h2>
<p>（1）git log命令显示从最近到最远的提交日志</p>
<p>（2）简短的显示提交日志</p>
<pre><code>$ git log --pretty=oneline
</code></pre>
<p>（3）</p>
<pre><code>$ git reset --hard HEAD^ 
</code></pre>
<p>上一个版本就是HEAD<sup>，上上一个版本就是HEAD</sup><sup>，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100。</p>
<p>（4） 查看版本的内容</p>
<pre><code>$ cat readme.txt
</code></pre>
<p>（5）</p>
<pre><code>$ git reset --hard 1094a 已经删除的版本号的前几位就可以
</code></pre>
<p>（6）用来记录每一次命令：</p>
<pre><code>$ git reflog
</code></pre>
<p>（7）HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令</p>
<pre><code>$ git reset --hard commit_id
</code></pre>
<p>（8）穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>（9）要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<h2 id="2工作区和暂存区">2.工作区和暂存区</h2>
<p>（1）工作区（working directory）</p>
<p>​		在电脑里面能看到的目录。例如learngit文件夹</p>
<p>（2）版本库</p>
<p>​		工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>​		git的版本库中最重要的是叫stage的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD</p>
<p>（3）往版本库中添加的时候分两步：</p>
<p>​		第一步，用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区。</p>
<p>​		第二步，用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>​		简单理解：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改</p>
<p><code>git status</code> 是查看工作区的状态<br>
（4）关系图示</p>
<figure data-type="image" tabindex="1"><img src="https://zzddl.github.io/zdl.github.io//post-images/1595902302037.jpg" alt="" loading="lazy"></figure>
<h2 id="3管理修改">3.管理修改</h2>
<p>（1）用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</p>
<p>（2）第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>
<p>（3）每次修改，如果不用git add到暂存区，那就不会加入到commit中</p>
<h2 id="4撤销修改">4.撤销修改</h2>
<p>（1）丢弃工作区的修改</p>
<pre><code>$ git checkout -- file
</code></pre>
<p>（2）撤销有两种情况：</p>
<p>​			第一种，自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态。</p>
<pre><code>	 第二种，已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

	 总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。
</code></pre>
<p>（3）<code>git checkout -- file</code>命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令</p>
<p>（4）命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p>（5）小结：</p>
<p>​		场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>​		场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>​		场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h2 id="5删除文件">5.删除文件</h2>
<p>（1）两种情况：</p>
<p>​		一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>，这样就不可以恢复了。</p>
<p>​		二是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本，<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p>（2）小结：</p>
<p>​		命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git学习（1）创建版本库]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/git-xue-xi-1chuang-jian-ban-ben-ku/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/git-xue-xi-1chuang-jian-ban-ben-ku/">
        </link>
        <updated>2020-07-28T02:02:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1创建版本库">1.创建版本库</h2>
<p>（1）选择一个合适的地方创建一个空的目录</p>
<pre><code>$ mkdir learngit

$ cd learngit  

$ pwd  命令用于显示当前目录
</code></pre>
<p>（2）通过git init命令把这个目录变成Git可以管理的仓库</p>
<pre><code>$ git init

Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>
<h2 id="2添加文件到文本库">2.添加文件到文本库</h2>
<p>（1）用命令git add告诉Git，把文件添加到仓库</p>
<pre><code>$ git add 文件名字
</code></pre>
<p>（2）用命令git commit告诉Git，把文件提交到仓库</p>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;横线部分文件描述
</code></pre>
<p>commit可以一次提交很多文件，所以你可以多次add不同的文件</p>
]]></content>
    </entry>
</feed>