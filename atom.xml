<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzddl.github.io/zdl.github.io/</id>
    <title>zdl&apos;s blog</title>
    <updated>2020-09-01T07:41:32.310Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzddl.github.io/zdl.github.io/"/>
    <link rel="self" href="https://zzddl.github.io/zdl.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzddl.github.io/zdl.github.io/images/avatar.png</logo>
    <icon>https://zzddl.github.io/zdl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zdl&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[大泥球（Big Ball of Mud）]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/">
        </link>
        <updated>2020-09-01T07:35:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义：</h2>
<p>大泥球是指一个随意化的杂乱的结构化系统，只是代码的堆砌和拼凑，往往会导致很多错误或者缺陷。</p>
<h2 id="缺点">缺点：</h2>
<p>无法使得系统内的信息得到更好的控制和共享，使得信息失去了应有的价值。大泥球般的系统的整体结构没有得到很好的界定，也就使得大泥球越发的复杂和杂乱无章。最终会使得这个系统的代码不被程序员理解，更无法对其修复，无法满足用户的需求变化。</p>
<h2 id="产生的原因">产生的原因：</h2>
<p>首先，程序员在编写程序或是系统时遇到问题后的解决方法，往往不是合适的或者最优的解法，而是方便修改的，变动最小的，这就为以后的系统架构的混乱甚至整个系统的奔溃埋下了隐患。其次，用户的需求或者编程的要求是在不断地变化的，任何一个已有的系统都随之会产生重大的变化，使得系统越来越复杂化，维护也越来越昂贵，另外编写人员的变动等等因素都会导致系统的退化，一步步变为大泥球。</p>
<p>所以，可以将其产生的原因归结为：一次性代码，碎片式增长，缺少前期设计，应对需求和架构变化过晚，程序员的经验，技巧，眼界的限制。</p>
<h2 id="避免或者修改大泥球的方法">避免或者修改大泥球的方法：</h2>
<p>首先，程序员或者设计师为了在预算中并按时交付高质量的软件，就需要关注软件的特性和功能，然后集中在架构和性能，使得软件设计初步就避免产生小的问题或者方向的偏差。其次，程序员在编写软件时要及时的解决出现的小问题或者原型概念等等，这样不会使得问题堆积导致后期的无法修改。另外，应当及时处理用户需求的变化，由于需求往往会随着时间的推移而变化，所以应当逐步的解决，并且鼓励和积极面对变化而不是掩盖问题。另外，要保持一直工作的状态，不断地维护需求和系统。但不应当进行一次彻底的检查，这样很可能会破坏系统。当然，软件系统也是在变化的，但是不同的部分会以不同的速度变化，所以应当使得它们的变化率一致。最坏的结果就是代码已经下降到了无法修复甚至理解的地步，那么就扔掉，重新开始。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java核心类]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/java-he-xin-lei/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/java-he-xin-lei/">
        </link>
        <updated>2020-08-25T12:50:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java核心类">java核心类</h2>
<h3 id="字符串和编码">字符串和编码</h3>
<ol>
<li>
<p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code></p>
</li>
<li>
<p>Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池</p>
</li>
<li>
<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
</li>
<li>
<p><code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</p>
</li>
<li>
<p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p>
</li>
<li>
<p><code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
</li>
<li>
<p><code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除。</p>
</li>
<li>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串</p>
</li>
<li>
<p>字符串中替换子串，有两种方法</p>
</li>
</ol>
<ul>
<li>根据字符或字符串替换</li>
</ul>
<pre><code class="language-java">String s = &quot;hello&quot;;
s.replace('l', 'w'); // &quot;hewwo&quot;，所有字符'l'被替换为'w'
s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;
</code></pre>
<ul>
<li>另一种是通过正则表达式替换：</li>
</ul>
<pre><code class="language-java">String s = &quot;A,,B;C ,D&quot;;
s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;
</code></pre>
<ol start="10">
<li>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</li>
</ol>
<pre><code class="language-java">String s = &quot;A,B,C,D&quot;;
String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}
</code></pre>
<ol start="11">
<li>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</li>
</ol>
<pre><code class="language-java">String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};
String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot;
</code></pre>
<ol start="12">
<li>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String s = &quot;Hi %s, your score is %d!&quot;;
        System.out.println(s.formatted(&quot;Alice&quot;, 80));
        System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5));
    }
}
</code></pre>
<p>常用的占位符：</p>
<ul>
<li><code>%s</code>：显示字符串；</li>
<li><code>%d</code>：显示整数；</li>
<li><code>%x</code>：显示十六进制整数；</li>
<li><code>%f</code>：显示浮点数。</li>
</ul>
<ol start="13">
<li>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法：</li>
</ol>
<pre><code class="language-java">String.valueOf(123); // &quot;123&quot;
String.valueOf(45.67); // &quot;45.67&quot;
String.valueOf(true); // &quot;true&quot;
String.valueOf(new Object()); // 类似java.lang.Object@636be97c
</code></pre>
<ol start="14">
<li>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</li>
</ol>
<pre><code class="language-java">int n1 = Integer.parseInt(&quot;123&quot;); // 123
int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255
</code></pre>
<ol start="15">
<li>把字符串转换为<code>boolean</code>类型：</li>
</ol>
<pre><code class="language-java">boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false
</code></pre>
<ol start="16">
<li><code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</li>
</ol>
<pre><code class="language-java">Integer.getInteger(&quot;java.version&quot;); // 版本号，11
</code></pre>
<ol start="17">
<li><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</li>
</ol>
<pre><code class="language-java">char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]
String s = new String(cs); // char[] -&gt; String
</code></pre>
<ol start="18">
<li>
<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        char[] cs = &quot;Hello&quot;.toCharArray();
        String s = new String(cs);
        System.out.println(s);
        cs[0] = 'X';
        System.out.println(s);
    }
}
</code></pre>
<p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>
</li>
<li>
<p>UTF-8<code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为</code>UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
</li>
</ol>
<pre><code class="language-java">byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换
byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
</code></pre>
<p>​		如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<pre><code class="language-java">byte[] b = ...
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
</code></pre>
<ol start="20">
<li>小结</li>
</ol>
<ul>
<li>Java字符串<code>String</code>是不可变对象；</li>
<li>字符串操作不改变原字符串内容，而是返回新字符串；</li>
<li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li>
<li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li>
<li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li>
<li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li>
</ul>
<h3 id="stringjoiner">StringJoiner</h3>
<p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p>
<p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p>
<h3 id="包装类型">包装类型</h3>
<p>1.Java的数据类型分两种：</p>
<ul>
<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li>
<li>引用类型：所有<code>class</code>和<code>interface</code>类型</li>
</ul>
<p><strong>引用类型</strong>可以赋值为<code>null</code>，表示空，但<strong>基本类型</strong>不能赋值为<code>null</code></p>
<p>2.想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p>
<pre><code class="language-java">public class Integer {
    private int value;

    public Integer(int value) {
        this.value = value;
    }

    public int intValue() {
        return this.value;
    }
}
</code></pre>
<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p>
<pre><code class="language-java">Integer n = null;
Integer n2 = new Integer(99);
int n3 = n2.intValue();
</code></pre>
<ol start="3">
<li></li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int i = 100;
        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):
        Integer n1 = new Integer(i);
        // 通过静态方法valueOf(int)创建Integer实例:
        Integer n2 = Integer.valueOf(i);
        // 通过静态方法valueOf(String)创建Integer实例:
        Integer n3 = Integer.valueOf(&quot;100&quot;);
        System.out.println(n3.intValue());
    }
}
</code></pre>
<p>运行结果：</p>
<p>Note: Main.java uses or overrides a deprecated API.<br>
Note: Recompile with -Xlint:deprecation for details.<br>
100</p>
<p>4.Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<pre><code class="language-java">Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()
</code></pre>
<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing）</p>
<p>把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）</p>
<p>5.<code>Integer</code>对象是不变的。</p>
<p>6.<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较</p>
<p>7.<code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制
        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制
        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制
        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制
        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制
    }
}
</code></pre>
<p>8.所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<pre><code class="language-java">// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();
</code></pre>
<p>9.小结</p>
<ul>
<li>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</li>
<li>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</li>
<li>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</li>
<li>包装类型的比较必须使用<code>equals()</code>；</li>
<li>整数和浮点数的包装类型都继承自<code>Number</code>；</li>
<li>包装类型提供了大量实用方法。</li>
</ul>
<h3 id="javabean">JavaBean</h3>
<p>1.如果读写方法符合以下这种命名规范：</p>
<pre><code class="language-java">// 读方法:
public Type getXyz()
// 写方法:
public void setXyz(Type value)
</code></pre>
<p>那么这种<code>class</code>被称为<code>JavaBean</code></p>
<p>2.<code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<pre><code class="language-java">// 读方法:
public boolean isChild()
// 写方法:
public void setChild(boolean value)
</code></pre>
<p>3.小结</p>
<ul>
<li>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</li>
<li>属性是一种通用的叫法，并非Java语法规定；</li>
<li>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</li>
<li>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</li>
</ul>
<h3 id="枚举类">枚举类</h3>
<p>1.enum</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println(&quot;Work at home!&quot;);
        } else {
            System.out.println(&quot;Work at office!&quot;);
        }
    }
}

enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
</code></pre>
<p>2.不同类型的枚举不能互相比较或者赋值，因为类型不符</p>
<p>3.<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点:</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p>4.返回常量名，例如：</p>
<pre><code class="language-java">String s = Weekday.SUN.name(); // &quot;SUN&quot;
</code></pre>
<p>5.返回定义的常量的顺序，从0开始计数，例如：</p>
<pre><code class="language-java">int n = Weekday.MON.ordinal(); // 1
</code></pre>
<p>6.默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法</p>
<p>7.枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中, 加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p>
<p>8.小结</p>
<ul>
<li>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum { … }</code>；</li>
<li>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</li>
<li>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</li>
<li>可以为<code>enum</code>编写构造方法、字段和方法</li>
<li><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</li>
<li><code>enum</code>适合用在<code>switch</code>语句中。</li>
</ul>
<h3 id="记录类">记录类</h3>
<p>1.使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ul>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>​	 每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ul>
<p>2.小结</p>
<p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p>
<ul>
<li>使用<code>record</code>定义的是不变类；</li>
<li>可以编写Compact Constructor对参数进行验证；</li>
<li>可以定义静态方法。</li>
</ul>
<h3 id="biginteger">BigInteger</h3>
<p><code>BigInteger</code>用于表示任意大小的整数；</p>
<p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p>
<p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p>
<h3 id="bigdecimal">BigDecimal</h3>
<p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<p>1.<code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
System.out.println(d1.scale()); // 2,两位小数
System.out.println(d2.scale()); // 4
System.out.println(d3.scale()); // 0
</code></pre>
<p>2.通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code></p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00

BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2
</code></pre>
<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>
<p>3.可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);
        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567
        System.out.println(d2);
        System.out.println(d3);
    }
}

</code></pre>
<p>做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断</p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽
</code></pre>
<p>4.还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BigDecimal n = new BigDecimal(&quot;12.345&quot;);
        BigDecimal m = new BigDecimal(&quot;0.12&quot;);
        BigDecimal[] dr = n.divideAndRemainder(m);
        System.out.println(dr[0]); // 102
        System.out.println(dr[1]); // 0.105
    }
}
</code></pre>
<p>5.比较BigDecimal</p>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<p>6.<code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>
<p>7.小结</p>
<p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p>
<p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p>
<h3 id="常用工具类">常用工具类</h3>
<h4 id="math">Math</h4>
<p>1.求绝对值：</p>
<pre><code class="language-java">Math.abs(-100); // 100
Math.abs(-7.8); // 7.8
</code></pre>
<p>2.最大、最小值</p>
<pre><code class="language-java">Math.max(100, 99); // 100
Math.min(1.2, 2.3); // 1.2
</code></pre>
<p>3.计算x的y次方</p>
<pre><code class="language-java">Math.pow(2, 10); // 2的10次方=1024
</code></pre>
<p>4.x开平方</p>
<pre><code class="language-java">Math.sqrt(2); // 1.414...
</code></pre>
<p>5.计算e的x次方</p>
<pre><code class="language-java">Math.exp(2); // 7.389...
</code></pre>
<p>6.计算以e为底的对数</p>
<pre><code class="language-java">Math.log(4); // 1.386...
</code></pre>
<p>7.计算以10为底的对数：</p>
<pre><code class="language-java">Math.log10(100); // 2
</code></pre>
<p>8.三角函数：</p>
<pre><code class="language-java">Math.sin(3.14); // 0.00159...
Math.cos(3.14); // -0.9999...
Math.tan(3.14); // -0.0015...
Math.asin(1.0); // 1.57079...
Math.acos(1.0); // 0.0
</code></pre>
<p>9.几个常量：</p>
<pre><code class="language-java">double pi = Math.PI; // 3.14159...
double e = Math.E; // 2.7182818...
Math.sin(Math.PI / 6); // sin(π/6) = 0.5
</code></pre>
<h4 id="random">Random</h4>
<p>1.<code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<pre><code class="language-java">Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
</code></pre>
<p>创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</p>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Random r = new Random(12345);
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(r.nextInt(100));
        }
        // 51, 80, 41, 28, 55...
    }
}
</code></pre>
<h4 id="securerandom">SecureRandom</h4>
<p>1.<code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<pre><code class="language-java">SecureRandom sr = new SecureRandom();
System.out.println(sr.nextInt(100));
</code></pre>
<p>2.<code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
        } catch (NoSuchAlgorithmException e) {
            sr = new SecureRandom(); // 获取普通的安全随机数生成器
        }
        byte[] buffer = new byte[16];
        sr.nextBytes(buffer); // 用安全随机数填充buffer
        System.out.println(Arrays.toString(buffer));
    }
}
</code></pre>
<p>3.<code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- HTML5 SSE]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-sse/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-sse/">
        </link>
        <updated>2020-08-19T02:54:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Server-Sent 事件允许网页从服务器获得更新。</strong></p>
<h3 id="接收-server-sent-事件通知">接收 Server-Sent 事件通知</h3>
<p>EventSource 对象用于接收服务器发送事件通知：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;获得服务器更新&lt;/h1&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;

&lt;script&gt;
if(typeof(EventSource)!==&quot;undefined&quot;)
  {
  var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;);
  source.onmessage=function(event)
    {
    document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
    };
  }
else
  {
  document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;;
  }
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>解释：</p>
<ul>
<li>创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 &quot;demo_sse.php&quot;）</li>
<li>每当接收到一次更新，就会发生 onmessage 事件</li>
<li>当 onmessage 事件发生时，把已接收的数据推入 id 为 &quot;result&quot; 的元素中</li>
</ul>
<h3 id="检测-server-sent-事件支持">检测 Server-Sent 事件支持</h3>
<pre><code class="language-html">if(typeof(EventSource) !== &quot;undefined&quot;) {
    // 是的！支持服务器发送事件！
    // 一些代码.....
} else {
    // 抱歉！不支持服务器发送事件！
}
</code></pre>
<h3 id="eventsource-对象">EventSource 对象</h3>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onopen</td>
<td style="text-align:left">当通往服务器的连接被打开</td>
</tr>
<tr>
<td style="text-align:left">onmessage</td>
<td style="text-align:left">当接收到消息</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:left">当发生错误</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- HTML5 web workers]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-web-workers/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-web-workers/">
        </link>
        <updated>2020-08-19T02:49:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="web-worker">Web Worker</h3>
<p>当在 HTML 页面中执行脚本时，页面是不可响应的，直到脚本已完成。</p>
<p>Web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能</p>
<h3 id="检测-web-worker-支持">检测 Web Worker 支持</h3>
<pre><code class="language-html">if (typeof(Worker) !== &quot;undefined&quot;) {
    // 是的！支持 Web worker！
    // 一些代码.....
} else {
    // 抱歉！不支持 Web Worker！
}
</code></pre>
<h3 id="创建-web-worker-文件">创建 Web Worker 文件</h3>
<p>让我们在一个外部 JavaScript 文件中创建我们的 web worker。</p>
<p>创建计数脚本。该脚本存储于 &quot;demo_workers.js&quot; 文件中：</p>
<pre><code class="language-html">var i = 0;

function timedCount() {
    i = i + 1;
    postMessage(i);
    setTimeout(&quot;timedCount()&quot;,500);
}

timedCount();
</code></pre>
<p>以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</p>
<h3 id="创建-web-worker-对象">创建 Web Worker 对象</h3>
<p>已经有 web worker 文件，需要从 HTML 页面调用它。</p>
<p>检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 &quot;demo_workers.js&quot; 中的代码：</p>
<pre><code class="language-html">if (typeof(w) == &quot;undefined&quot;) {
    w = new Worker(&quot;demo_workers.js&quot;);
}
</code></pre>
<p>然后我们就可以从 web worker 发生和接收消息了。</p>
<p>向 web worker 添加一个 &quot;onmessage&quot; 事件监听器：</p>
<pre><code class="language-html">w.onmessage = function(event){
    document.getElementById(&quot;result&quot;).innerHTML = event.data;
};
</code></pre>
<p>当 web worker 传送消息时，会执行事件监听器中的代码。来自 web worker 的数据会存储于 event.data 中。</p>
<h3 id="终止-web-worker">终止 Web Worker</h3>
<p>当创建 web worker 后，它会继续监听消息（即使在外部脚本完成后）直到其被终止为止。</p>
<p>终止并且释放资源，使用 terminate() 方法：</p>
<pre><code class="language-html">w.terminate();
</code></pre>
<h3 id="复用-web-worker">复用 Web Worker</h3>
<p>把 worker 变量设置为 undefined，在其被终止后，可以重复使用该代码：</p>
<pre><code class="language-html">w = undefined;
</code></pre>
<h3 id="完整的-web-worker-实例代码">完整的 Web Worker 实例代码</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;
&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt; 
&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;
&lt;br&gt;&lt;br&gt;

&lt;script&gt;
var w;

function startWorker() {
    if(typeof(Worker) !== &quot;undefined&quot;) {
        if(typeof(w) == &quot;undefined&quot;) {
            w = new Worker(&quot;demo_workers.js&quot;);
        }
        w.onmessage = function(event) {
            document.getElementById(&quot;result&quot;).innerHTML = event.data;
        };
    } else {
        document.getElementById(&quot;result&quot;).innerHTML = &quot;Sorry! No Web Worker support.&quot;;
    }
}

function stopWorker() { 
    w.terminate();
    w = undefined;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="web-worker-和-dom">Web Worker 和 DOM</h3>
<p>由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：</p>
<ul>
<li>window 对象</li>
<li>document 对象</li>
<li>parent 对象</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- HTML5应用缓存]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-ying-yong-huan-cun/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-ying-yong-huan-cun/">
        </link>
        <updated>2020-08-19T02:31:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>使用应用程序缓存，通过创建 cache manifest 文件，可轻松创建 web 应用的离线版本。</strong></p>
<h3 id="应用程序缓存">应用程序缓存</h3>
<p>HTML5 引入了应用程序缓存（Application Cache），可对 web 应用进行缓存，并可在没有因特网连接时进行访问。</p>
<p>三个优势：</p>
<ol>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源</li>
</ol>
<h3 id="cache-manifest-基础">Cache Manifest 基础</h3>
<p>如需启用应用程序缓存，请在文档的 &lt; html&gt; 标签中包含 manifest 属性：</p>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html manifest=&quot;demo.appcache&quot;&gt;
...
&lt;/html&gt;
</code></pre>
<p>每个指定了 manifest 的页面在用户对其访问时都会被缓存</p>
<p>manifest 文件的建议文件扩展名是：&quot;.appcache&quot;。</p>
<h3 id="manifest-文件">Manifest 文件</h3>
<p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p>
<p>三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ul>
<h3 id="cache-manifest">CACHE MANIFEST</h3>
<pre><code class="language-html">CACHE MANIFEST
/theme.css
/logo.gif
/main.js
</code></pre>
<p>上述列出三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件被加载后，浏览器会从网站的根目录下载这三个文件。断开网络连接，这些资源仍然可用。</p>
<h3 id="network">NETWORK</h3>
<p>NETWORK 部分规定文件 &quot;login.php&quot; 永远不会被缓存，且离线时是不可用的：</p>
<pre><code class="language-html">NETWORK:
login.asp
</code></pre>
<p>可以使用星号来指示所有其他其他资源/文件都需要因特网连接：</p>
<pre><code class="language-html">NETWORK:
*

FALLBACK
</code></pre>
<p>下面的 FALLBACK 部分规定如果无法建立因特网连接，则用 &quot;offline.html&quot; 替代 /html/ 目录中的所有文件：</p>
<pre><code class="language-html">FALLBACK:
/html/ /offline.html
</code></pre>
<p>**注释：**第一个 URI 是资源，第二个是替补。</p>
<h3 id="实例-完整的-cache-manifest-文件">实例 - 完整的 Cache Manifest 文件</h3>
<pre><code class="language-html">CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js

NETWORK:
login.asp

FALLBACK:
/html/ /offline.html
</code></pre>
<p>以 &quot;#&quot; 开头的是注释行</p>
<h3 id="cache-manifest-实例">Cache Manifest 实例</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html manifest=&quot;/example/html5/demo_html.appcache&quot;&gt;
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/example/html5/demo_time.js&quot;&gt;
&lt;/script&gt;
&lt;p id=&quot;timePara&quot;&gt;&lt;button onclick=&quot;getDateTime()&quot;&gt;获得日期和事件&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i/w3school_banner.gif&quot; /&gt;&lt;/p&gt;
&lt;p&gt;请打开&lt;a href=&quot;/example/html5/html5_html_manifest.html&quot; target=&quot;_blank&quot;&gt;这个页面&lt;/a&gt;，然后脱机浏览，重新加载页面。页面中的脚本和图像依然可用。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!DOCTYPE html>
<html manifest="/example/html5/demo_html.appcache">
<body>
<script type="text/javascript" src="/example/html5/demo_time.js">
</script>
<p id="timePara"><button onclick="getDateTime()">获得日期和事件</button></p>
<p><img src="/i/w3school_banner.gif" /></p>
<p>请打开<a href="/example/html5/html5_html_manifest.html" target="_blank">这个页面</a>，然后脱机浏览，重新加载页面。页面中的脚本和图像依然可用。</p>
</body>
</html>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- html5本地存储]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-ben-di-cun-chu/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-ben-di-cun-chu/">
        </link>
        <updated>2020-08-19T02:15:50.000Z</updated>
        <content type="html"><![CDATA[<p><strong>HTML 本地存储：优于 cookies。</strong></p>
<h3 id="html本地存储">html本地存储</h3>
<p>通过本地存储（Local Storage），web 应用程序能够在用户浏览器中对数据进行本地的存储。</p>
<p>存储限制比cookies大得多。</p>
<h3 id="html-本地存储对象">HTML 本地存储对象</h3>
<p>HTML 本地存储提供了两个在客户端存储数据的对象：</p>
<ul>
<li>window.localStorage - 存储没有截止日期的数据</li>
<li>window.sessionStorage - 针对一个 session 来存储数据（当关闭浏览器标签页时数据会丢失）</li>
</ul>
<p>在使用本地存储时，请检测 localStorage 和 sessionStorage 的浏览器支持：</p>
<pre><code class="language-html">if (typeof(Storage) !== &quot;undefined&quot;) {
    // 针对 localStorage/sessionStorage 的代码
} else {
    // 抱歉！不支持 Web Storage ..
}
</code></pre>
<h3 id="localstorage-对象">localStorage 对象</h3>
<p>localStorage 对象存储的是没有截止日期的数据。当浏览器被关闭时数据不会被删除，在下一天、周或年中，都是可用的。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;

&lt;script&gt;
// Check browser support
if (typeof(Storage) !== &quot;undefined&quot;) {
    // Store
    localStorage.setItem(&quot;lastname&quot;, &quot;Gates&quot;);
    // Retrieve
    document.getElementById(&quot;result&quot;).innerHTML = localStorage.getItem(&quot;lastname&quot;);
} else {
    document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉！您的浏览器不支持 Web Storage ...&quot;;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>解释：</p>
<ul>
<li>创建 localStorage 名称/值对，其中：name=&quot;lastname&quot;，value=&quot;Gates&quot;</li>
<li>取回 &quot;lastname&quot; 的值，并把它插到 id=&quot;result&quot; 的元素中</li>
</ul>
<p>也可以这样：</p>
<pre><code class="language-html">// 存储
localStorage.lastname = &quot;Gates&quot;;
// 取回
document.getElementById(&quot;result&quot;).innerHTML = localStorage.lastname;
</code></pre>
<p>删除 &quot;lastname&quot; localStorage 项目的语法如下：</p>
<pre><code class="language-html">localStorage.removeItem(&quot;lastname&quot;);
</code></pre>
<h3 id="实例-用户点击次数">实例-用户点击次数</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function clickCounter() {
    if(typeof(Storage) !== &quot;undefined&quot;) {
        if (localStorage.clickcount) {
            localStorage.clickcount = Number(localStorage.clickcount)+1;
        } else {
            localStorage.clickcount = 1;
        }
        document.getElementById(&quot;result&quot;).innerHTML = &quot;您已经点击这个按钮 &quot; + localStorage.clickcount + &quot; 次。&quot;;
    } else {
        document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉！您的浏览器不支持 Web Storage ...&quot;;
    }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;&lt;button onclick=&quot;clickCounter()&quot; type=&quot;button&quot;&gt;请点击这里！&lt;/button&gt;&lt;/p&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;p&gt;请点击按钮使计数器递增。&lt;/p&gt;
&lt;p&gt;请关闭浏览器或标签页，然后再试一次，计数器将继续计数（不会重置）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!DOCTYPE html>
<html>
<head>
<script>
function clickCounter() {
    if(typeof(Storage) !== "undefined") {
        if (localStorage.clickcount) {
            localStorage.clickcount = Number(localStorage.clickcount)+1;
        } else {
            localStorage.clickcount = 1;
        }
        document.getElementById("result").innerHTML = "您已经点击这个按钮 " + localStorage.clickcount + " 次。";
    } else {
        document.getElementById("result").innerHTML = "抱歉！您的浏览器不支持 Web Storage ...";
    }
}
</script>
</head>
<body>
<p><button onclick="clickCounter()" type="button">请点击这里！</button></p>
<div id="result"></div>
<p>请点击按钮使计数器递增。</p>
<p>请关闭浏览器或标签页，然后再试一次，计数器将继续计数（不会重置）。</p>
</body>
</html>
<h3 id="sessionstorage-对象">sessionStorage 对象</h3>
<p>sessionStorage 对象等同 localStorage 对象，不同之处在于只对一个 session 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。</p>
<p>当前session中用户点击次数：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function clickCounter() {
    if(typeof(Storage) !== &quot;undefined&quot;) {
        if (sessionStorage.clickcount) {
            sessionStorage.clickcount = Number(sessionStorage.clickcount)+1;
        } else {
            sessionStorage.clickcount = 1;
        }
        document.getElementById(&quot;result&quot;).innerHTML = &quot;在本 session 中，您已经点击这个按钮 &quot; + sessionStorage.clickcount + &quot; 次。&quot;;
    } else {
        document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉！您的浏览器不支持 Web Storage ...&quot;;
    }
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;&lt;button onclick=&quot;clickCounter()&quot; type=&quot;button&quot;&gt;请点击这里&lt;/button&gt;&lt;/p&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;
&lt;p&gt;请点击按钮使计数器递增。&lt;/p&gt;
&lt;p&gt;请关闭浏览器或标签页，然后再试一次，计数器会重置。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!DOCTYPE html>
<html>
<head>
<script>
function clickCounter() {
    if(typeof(Storage) !== "undefined") {
        if (sessionStorage.clickcount) {
            sessionStorage.clickcount = Number(sessionStorage.clickcount)+1;
        } else {
            sessionStorage.clickcount = 1;
        }
        document.getElementById("result").innerHTML = "在本 session 中，您已经点击这个按钮 " + sessionStorage.clickcount + " 次。";
    } else {
        document.getElementById("result").innerHTML = "抱歉！您的浏览器不支持 Web Storage ...";
    }
}
</script>
</head>
<body>
<p><button onclick="clickCounter()" type="button">请点击这里</button></p>
<div id="result"></div>
<p>请点击按钮使计数器递增。</p>
<p>请关闭浏览器或标签页，然后再试一次，计数器会重置。</p>
</body>
</html>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.18 -- HTML5拖放]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html5-tuo-fang/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html5-tuo-fang/">
        </link>
        <updated>2020-08-18T15:34:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="html-拖放实例">HTML 拖放实例</h3>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function allowDrop(ev) {
    ev.preventDefault();
}

function drag(ev) {
    ev.dataTransfer.setData(&quot;text&quot;, ev.target.id);
}

function drop(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData(&quot;text&quot;);
    ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;

&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot;&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="把元素设置为可拖放">把元素设置为可拖放</h3>
<pre><code class="language-html">&lt;img draggable=&quot;true&quot;&gt;
</code></pre>
<h3 id="拖放的内容-ondragstart-和-setdata">拖放的内容 - ondragstart 和 setData()</h3>
<p>ondragstart 属性调用了一个 drag(event) 函数，规定拖动什么数据</p>
<p>dataTransfer.setData() 方法设置被拖动数据的数据类型和值</p>
<pre><code class="language-html">function drag(ev) {
    ev.dataTransfer.setData(&quot;text&quot;, ev.target.id);
}
</code></pre>
<h3 id="拖到何处-ondragover">拖到何处 - ondragover</h3>
<p>由 ondragover 事件的 event.preventDefault() 方法完成</p>
<pre><code class="language-html">event.preventDefault()
</code></pre>
<h3 id="进行放置-ondrop">进行放置 - ondrop</h3>
<p>ondrop 属性调用了一个函数，drop(event)</p>
<pre><code class="language-html">function drop(ev) {
    ev.preventDefault();
    var data = ev.dataTransfer.getData(&quot;text&quot;);
    ev.target.appendChild(document.getElementById(data));
}
</code></pre>
<p>解释：</p>
<ul>
<li>调用 preventDefault() 来阻止数据的浏览器默认处理方式（drop 事件的默认行为是以链接形式打开）</li>
<li>通过 dataTransfer.getData() 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据</li>
<li>被拖数据是被拖元素的 id (&quot;drag1&quot;)</li>
<li>把被拖元素追加到放置元素中</li>
</ul>
<h3 id="来回拖放图片">来回拖放图片</h3>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
#div1, #div2
{float:left; width:198px; height:66px; margin:10px;padding:10px;border:1px solid #aaaaaa;}
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function allowDrop(ev)
{
ev.preventDefault();
}

function drag(ev)
{
ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
}

function drop(ev)
{
ev.preventDefault();
var data=ev.dataTransfer.getData(&quot;Text&quot;);
ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;
  &lt;img src=&quot;/i/eg_dragdrop_w3school.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; /&gt;
&lt;/div&gt;
&lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.18 -- html5地理位置]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html5-di-li-wei-zhi/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html5-di-li-wei-zhi/">
        </link>
        <updated>2020-08-18T15:26:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="html5-使用地理定位">HTML5 - 使用地理定位</h3>
<p>getCurrentPosition() 方法来获得用户的位置。</p>
<pre><code class="language-HTML">&lt;script&gt;
var x=document.getElementById(&quot;demo&quot;);
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.getCurrentPosition(showPosition);
    }
  else{x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}
  }
function showPosition(position)
  {
  x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +
  &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;
  }
&lt;/script&gt;
</code></pre>
<p>如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象</p>
<p>showPosition() 函数获得并显示经度和纬度</p>
<h3 id="处理错误和拒绝">处理错误和拒绝</h3>
<p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数：</p>
<pre><code class="language-html">function showError(error)
  {
  switch(error.code)
    {
    case error.PERMISSION_DENIED:
      x.innerHTML=&quot;User denied the request for Geolocation.&quot;
      break;
    case error.POSITION_UNAVAILABLE:
      x.innerHTML=&quot;Location information is unavailable.&quot;
      break;
    case error.TIMEOUT:
      x.innerHTML=&quot;The request to get user location timed out.&quot;
      break;
    case error.UNKNOWN_ERROR:
      x.innerHTML=&quot;An unknown error occurred.&quot;
      break;
    }
  }
</code></pre>
<p>错误代码：</p>
<ul>
<li>Permission denied - 用户不允许地理定位</li>
<li>Position unavailable - 无法获取当前位置</li>
<li>Timeout - 操作超时</li>
</ul>
<h3 id="在地图中显示结果">在地图中显示结果</h3>
<p>如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图：</p>
<pre><code class="language-html">function showPosition(position)
{
var latlon=position.coords.latitude+&quot;,&quot;+position.coords.longitude;

var img_url=&quot;http://maps.googleapis.com/maps/api/staticmap?center=&quot;
+latlon+&quot;&amp;zoom=14&amp;size=400x300&amp;sensor=false&quot;;

document.getElementById(&quot;mapholder&quot;).innerHTML=&quot;&lt;img src='&quot;+img_url+&quot;' /&gt;&quot;;
}
</code></pre>
<h3 id="getcurrentposition-方法-返回数据">getCurrentPosition() 方法 - 返回数据</h3>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">coords.latitude</td>
<td style="text-align:left">十进制数的纬度</td>
</tr>
<tr>
<td style="text-align:left">coords.longitude</td>
<td style="text-align:left">十进制数的经度</td>
</tr>
<tr>
<td style="text-align:left">coords.accuracy</td>
<td style="text-align:left">位置精度</td>
</tr>
<tr>
<td style="text-align:left">coords.altitude</td>
<td style="text-align:left">海拔，海平面以上以米计</td>
</tr>
<tr>
<td style="text-align:left">coords.altitudeAccuracy</td>
<td style="text-align:left">位置的海拔精度</td>
</tr>
<tr>
<td style="text-align:left">coords.heading</td>
<td style="text-align:left">方向，从正北开始以度计</td>
</tr>
<tr>
<td style="text-align:left">coords.speed</td>
<td style="text-align:left">速度，以米/每秒计</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">响应的日期/时间</td>
</tr>
</tbody>
</table>
<h3 id="geolocation-对象-其他有趣的方法">Geolocation 对象 - 其他有趣的方法</h3>
<p>watchPosition() - 返回用户的当前位置，并继续返回用户移动时的更新位置。</p>
<p>clearWatch() - 停止 watchPosition() 方法</p>
<pre><code class="language-html">&lt;script&gt;
var x=document.getElementById(&quot;demo&quot;);
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.watchPosition(showPosition);
    }
  else{x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;}
  }
function showPosition(position)
  {
  x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +
  &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;
  }
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.18 -- HTML媒体]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html-mei-ti/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html-mei-ti/">
        </link>
        <updated>2020-08-18T15:14:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="html多媒体">HTML多媒体</h2>
<h3 id="视频格式">视频格式</h3>
<table>
<thead>
<tr>
<th>格式</th>
<th>文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVI</td>
<td>.avi</td>
</tr>
<tr>
<td>WMV</td>
<td>.wmv</td>
</tr>
<tr>
<td>MPEG</td>
<td>.mpg<br />.mpeg</td>
</tr>
<tr>
<td>QuickTime</td>
<td>.mov</td>
</tr>
<tr>
<td>RealVideo</td>
<td>.rm<br />.ram</td>
</tr>
<tr>
<td>Flash</td>
<td>.swf <br />.flv</td>
</tr>
<tr>
<td>Mpeg-4</td>
<td>.mp4</td>
</tr>
</tbody>
</table>
<h3 id="声音格式">声音格式</h3>
<table>
<thead>
<tr>
<th>格式</th>
<th>文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>MIDI</td>
<td>.mid<br /> .midi</td>
</tr>
<tr>
<td>RealAudio</td>
<td>.rm<br />.ram</td>
</tr>
<tr>
<td>Wave</td>
<td>.wav</td>
</tr>
<tr>
<td>WMA</td>
<td>.wma</td>
</tr>
<tr>
<td>MP3</td>
<td>.mp3 <br />.mpga</td>
</tr>
</tbody>
</table>
<h2 id="html对象">HTML对象</h2>
<h3 id="html-object-元素">HTML Object 元素</h3>
<p><strong>&lt; object&gt; 的作用是支持 HTML 助手（插件）。</strong></p>
<h3 id="使用-quicktime-来播放-wave-音频">使用 QuickTime 来播放 Wave 音频</h3>
<pre><code class="language-html">&lt;object width=&quot;420&quot; height=&quot;360&quot;
classid=&quot;clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B&quot;
codebase=&quot;http://www.apple.com/qtactivex/qtplugin.cab&quot;&gt;
&lt;param name=&quot;src&quot; value=&quot;bird.wav&quot; /&gt;
&lt;param name=&quot;controller&quot; value=&quot;true&quot; /&gt;
&lt;/object&gt;
</code></pre>
<h3 id="使用-quicktime-来播放-mp4-视频">使用 QuickTime 来播放 MP4 视频</h3>
<pre><code class="language-html">&lt;object width=&quot;420&quot; height=&quot;360&quot;
classid=&quot;clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B&quot;
codebase=&quot;http://www.apple.com/qtactivex/qtplugin.cab&quot;&gt;
&lt;param name=&quot;src&quot; value=&quot;movie.mp4&quot; /&gt;
&lt;param name=&quot;controller&quot; value=&quot;true&quot; /&gt;
&lt;/object&gt;
</code></pre>
<h3 id="使用-flash-来播放-swf-视频">使用 Flash 来播放 SWF 视频</h3>
<pre><code class="language-html">&lt;object width=&quot;400&quot; height=&quot;40&quot;
classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot;
codebase=&quot;http://fpdownload.macromedia.com/
pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0&quot;&gt;
&lt;param name=&quot;SRC&quot; value=&quot;bookmark.swf&quot;&gt;
&lt;embed src=&quot;bookmark.swf&quot; width=&quot;400&quot; height=&quot;40&quot;&gt;&lt;/embed&gt;
&lt;/object&gt;
</code></pre>
<h3 id="使用-windows-media-player-来播放-wmv-影片">使用 Windows Media Player 来播放 WMV 影片</h3>
<pre><code class="language-html">&lt;object width=&quot;100%&quot; height=&quot;100%&quot;
type=&quot;video/x-ms-asf&quot; url=&quot;3d.wmv&quot; data=&quot;3d.wmv&quot;
classid=&quot;CLSID:6BF52A52-394A-11d3-B153-00C04F79FAA6&quot;&gt;
&lt;param name=&quot;url&quot; value=&quot;3d.wmv&quot;&gt;
&lt;param name=&quot;filename&quot; value=&quot;3d.wmv&quot;&gt;
&lt;param name=&quot;autostart&quot; value=&quot;1&quot;&gt;
&lt;param name=&quot;uiMode&quot; value=&quot;full&quot; /&gt;
&lt;param name=&quot;autosize&quot; value=&quot;1&quot;&gt;
&lt;param name=&quot;playcount&quot; value=&quot;1&quot;&gt;
&lt;embed type=&quot;application/x-mplayer2&quot; src=&quot;3d.wmv&quot; width=&quot;100%&quot;
 height=&quot;100%&quot; autostart=&quot;true&quot; showcontrols=&quot;true&quot; 
pluginspage=&quot;http://www.microsoft.com/Windows/MediaPlayer/&quot;&gt;&lt;/embed&gt;
&lt;/object&gt;
</code></pre>
<h2 id="html-音频">HTML 音频</h2>
<h3 id="使用-embed-元素">使用 &lt; embed&gt; 元素</h3>
<p>&lt; embed&gt; 标签定义外部（非 HTML）内容的容器。</p>
<p>这个标签只能在HTML5中使用。</p>
<pre><code class="language-html">&lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;song.mp3&quot; /&gt;
</code></pre>
<p>&lt; embed&gt;的问题</p>
<ul>
<li>&lt; embed&gt; 标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。</li>
<li>不同的浏览器对音频格式的支持也不同。</li>
<li>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。</li>
<li>如果未安装插件，无法播放音频。</li>
<li>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li>
</ul>
<h3 id="使用-object-元素">使用 &lt; object&gt; 元素</h3>
<p>&lt; object tag&gt; 标签也可以定义外部（非 HTML）内容的容器。</p>
<pre><code class="language-html">&lt;object height=&quot;100&quot; width=&quot;100&quot; data=&quot;song.mp3&quot;&gt;&lt;/object&gt;
</code></pre>
<p>&lt; object&gt;的问题：</p>
<ul>
<li>不同的浏览器对音频格式的支持也不同。</li>
<li>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。</li>
<li>如果未安装插件，无法播放音频。</li>
<li>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li>
</ul>
<h3 id="使用-html5-audio-元素">使用 HTML5 &lt; audio&gt; 元素</h3>
<p>&lt; audio&gt; 元素是一个 HTML5 元素，在 HTML 4 中是非法的</p>
<pre><code class="language-html">&lt;audio controls=&quot;controls&quot;&gt;
  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt;
  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt;
Your browser does not support this audio format.
&lt;/audio&gt;
</code></pre>
<p>&lt; audio&gt;的问题：</p>
<ul>
<li>&lt; audio&gt; 标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。</li>
<li>您必须把音频文件转换为不同的格式。</li>
<li>&lt; audio&gt; 元素在老式浏览器中不起作用。</li>
</ul>
<h3 id="最好的-html-解决方法">最好的 HTML 解决方法</h3>
<pre><code class="language-html">&lt;audio controls=&quot;controls&quot; height=&quot;100&quot; width=&quot;100&quot;&gt;
  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt;
  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt;
&lt;embed height=&quot;100&quot; width=&quot;100&quot; src=&quot;song.mp3&quot; /&gt;
&lt;/audio&gt;
</code></pre>
<p>HTML5 &lt; audio&gt; 元素会尝试以 mp3 或 ogg 来播放音频。如果失败，代码将回退尝试 &lt; embed&gt; 元素。</p>
<p>问题：</p>
<ul>
<li>必须把音频转换为不同的格式。</li>
<li>&lt; audio&gt; 元素无法通过 HTML 4 和 XHTML 验证。</li>
<li>&lt; embed&gt; 元素无法通过 HTML 4 和 XHTML 验证。</li>
<li>&lt; embed&gt; 元素无法回退来显示错误消息。</li>
</ul>
<h3 id="雅虎媒体播放器">雅虎媒体播放器</h3>
<pre><code class="language-html">&lt;a href=&quot;song.mp3&quot;&gt;Play Sound&lt;/a&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://mediaplayer.yahoo.com/js&quot;&gt;
&lt;/script&gt;
</code></pre>
<h3 id="使用超链接">使用超链接</h3>
<p>如果网页包含指向媒体文件的超链接，大多数浏览器会使用“<strong>辅助应用程序</strong>”来播放文件。</p>
<pre><code class="language-html">&lt;a href=&quot;song.mp3&quot;&gt;Play the sound&lt;/a&gt;
</code></pre>
<h3 id="html-401-多媒体标签">HTML 4.01 多媒体标签</h3>
<table>
<thead>
<tr>
<th style="text-align:left">标签</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt; applet&gt;</td>
<td style="text-align:left">不赞成。定义内嵌 applet。</td>
</tr>
<tr>
<td style="text-align:left">&lt; embed&gt;</td>
<td style="text-align:left">HTML4 中不赞成，HTML5 中允许。定义内嵌对象。</td>
</tr>
<tr>
<td style="text-align:left">&lt; object&gt;</td>
<td style="text-align:left">定义内嵌对象。</td>
</tr>
<tr>
<td style="text-align:left">&lt; param&gt;</td>
<td style="text-align:left">定义对象的参数。</td>
</tr>
</tbody>
</table>
<h3 id="html-5-多媒体标签">HTML 5 多媒体标签</h3>
<table>
<thead>
<tr>
<th style="text-align:left">标签</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt; audio&gt;</td>
<td style="text-align:left">标签定义声音，比如音乐或其他音频流。</td>
</tr>
<tr>
<td style="text-align:left">&lt; embed&gt;</td>
<td style="text-align:left">标签定义嵌入的内容，比如插件。</td>
</tr>
</tbody>
</table>
<h2 id="html-视频">HTML 视频</h2>
<h3 id="使用-embed-标签">使用 &lt; embed&gt; 标签</h3>
<pre><code class="language-html">&lt;embed src=&quot;movie.swf&quot; height=&quot;200&quot; width=&quot;200&quot;/&gt;
</code></pre>
<p>问题:</p>
<ul>
<li>HTML4 无法识别 &lt; embed&gt; 标签。您的页面无法通过验证。</li>
<li>如果浏览器不支持 Flash，那么视频将无法播放</li>
<li>iPad 和 iPhone 不能显示 Flash 视频。</li>
<li>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li>
</ul>
<h3 id="使用-object-标签">使用 &lt; object&gt; 标签</h3>
<pre><code class="language-html">&lt;object data=&quot;movie.swf&quot; height=&quot;200&quot; width=&quot;200&quot;/&gt;
</code></pre>
<p>问题：</p>
<ul>
<li>如果浏览器不支持 Flash，将无法播放视频。</li>
<li>iPad 和 iPhone 不能显示 Flash 视频。</li>
<li>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li>
</ul>
<h3 id="使用-video-标签">使用 &lt; video&gt; 标签</h3>
<p>&lt; video&gt; 是 HTML 5 中的新标签。</p>
<pre><code class="language-html">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;
  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot; /&gt;
  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; /&gt;
  &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; /&gt;
Your browser does not support the video tag.
&lt;/video&gt;
</code></pre>
<p>问题：</p>
<ul>
<li>必须把视频转换为很多不同的格式。</li>
<li>&lt; video&gt; 元素在老式浏览器中无效。</li>
<li>&lt; video&gt; 元素无法通过 HTML 4 和 XHTML 验证。</li>
</ul>
<h3 id="最好的-html-解决方法-2">最好的 HTML 解决方法</h3>
<p>HTML 5 + &lt; object&gt; + &lt; embed&gt;</p>
<pre><code class="language-html">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;
  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot; /&gt;
  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; /&gt;
  &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; /&gt;
  &lt;object data=&quot;movie.mp4&quot; width=&quot;320&quot; height=&quot;240&quot;&gt;
    &lt;embed src=&quot;movie.swf&quot; width=&quot;320&quot; height=&quot;240&quot; /&gt;
  &lt;/object&gt;
&lt;/video&gt;
</code></pre>
<p>问题：</p>
<ul>
<li>必须把视频转换为很多不同的格式</li>
<li>&lt; video&gt; 元素无法通过 HTML 4 和 XHTML 验证。</li>
<li>&lt; embed&gt; 元素无法通过 HTML 4 和 XHTML 验证。</li>
</ul>
<h3 id="优酷解决方案">优酷解决方案</h3>
<pre><code class="language-html">&lt;embed src=&quot;http://player.youku.com/player.php/sid/XMzI2NTc4NTMy/v.swf&quot; 
width=&quot;480&quot; height=&quot;400&quot; 
type=&quot;application/x-shockwave-flash&quot;&gt;
&lt;/embed&gt;
</code></pre>
<h3 id="使用超链接-2">使用超链接</h3>
<pre><code class="language-html">&lt;a href=&quot;movie.swf&quot;&gt;Play a video file&lt;/a&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.18 -- html图形（2）SVG]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html-tu-xing-2svg/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-818-html-tu-xing-2svg/">
        </link>
        <updated>2020-08-18T14:40:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是svg">什么是SVG？</h3>
<ul>
<li>SVG指可伸缩矢量图形</li>
<li>使用XML定义图形</li>
<li>图像在放大或者改变尺寸时图形指令不会有损失</li>
</ul>
<h3 id="svg-的优势">SVG 的优势</h3>
<ul>
<li>SVG 图像可通过文本编辑器来创建和修改</li>
<li>SVG 图像可被搜索、索引、脚本化或压缩</li>
<li>SVG 是可伸缩的</li>
<li>SVG 图像可在任何的分辨率下被高质量地打印</li>
<li>SVG 可在图像质量不下降的情况下被放大</li>
</ul>
<h3 id="把-svg-直接嵌入-html-页面">把 SVG 直接嵌入 HTML 页面</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt;
   &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot;
   style=&quot;fill:red;stroke:blue;stroke-width:3;fill-rule:evenodd;&quot; /&gt;
&lt;/svg&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>![](E:\张丁龙\web前端\图\批注 2020-08-18 223645.jpg)</p>
<h2 id="canvas-与-svg-的比较">Canvas 与 SVG 的比较</h2>
<h4 id="canvas">Canvas</h4>
<ul>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
<h4 id="svg">SVG</h4>
<ul>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序</li>
<li>复杂度高会减慢渲染速度（过度使用DOM）</li>
<li>不适合游戏应用</li>
</ul>
]]></content>
    </entry>
</feed>