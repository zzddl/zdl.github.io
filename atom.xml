<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzddl.github.io/zdl.github.io/</id>
    <title>zdl&apos;s blog</title>
    <updated>2021-05-01T01:11:15.790Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzddl.github.io/zdl.github.io/"/>
    <link rel="self" href="https://zzddl.github.io/zdl.github.io/atom.xml"/>
    <subtitle>开放，共享</subtitle>
    <logo>https://zzddl.github.io/zdl.github.io/images/avatar.png</logo>
    <icon>https://zzddl.github.io/zdl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zdl&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Mysql命令]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/mysql-ming-ling/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/mysql-ming-ling/">
        </link>
        <updated>2020-12-24T07:47:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="连接mysql">连接Mysql</h3>
<pre><code class="language-mysql">mysql -h主机地址 -u用户名 -p用户密码
</code></pre>
<h3 id="修改密码">修改密码</h3>
<pre><code class="language-mysql">mysqladmin -u用户名 -p旧密码 password 新密码
</code></pre>
<h3 id="增加新用户">增加新用户</h3>
<pre><code class="language-csharp">grant select on 数据库.* to 用户名@登录主机 identified by “密码”
</code></pre>
<p>增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：</p>
<pre><code class="language-mysql">grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”;
</code></pre>
<p>设定只能通过mysql主机登录访问，无法通过internet访问：</p>
<pre><code class="language-mysql">grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “ ”;
</code></pre>
<h3 id="数据库操作">数据库操作</h3>
<h4 id="创建数据库">创建数据库</h4>
<pre><code class="language-mysql">create database database_name;
</code></pre>
<h3 id="数据库表数据操作">数据库表数据操作</h3>
<h4 id="显示所有数据库">显示所有数据库</h4>
<pre><code class="language-mysql">show databases;
</code></pre>
<h4 id="进入某个数据库">进入某个数据库</h4>
<pre><code class="language-mysql">use dataBase_name;
</code></pre>
<h4 id="显示数据库中的所有表">显示数据库中的所有表</h4>
<pre><code class="language-mysql">show tables;
</code></pre>
<h4 id="显示表的字段信息">显示表的字段信息</h4>
<pre><code class="language-mysql">desc table_name;
</code></pre>
<h4 id="创建表">创建表</h4>
<pre><code class="language-mysql">create table  表名 (name char(100), path char(100), count int(10), firstName char(100), firstMD5 char(100), secondName char(100), secondMD5 char(100), thirdName char(100), thirdMD5 char(100));
</code></pre>
<h4 id="修改表名">修改表名</h4>
<pre><code class="language-mysql">rename table 旧表名 to 新表名
</code></pre>
<h4 id="删除表">删除表</h4>
<pre><code class="language-mysql">drop table 表名;
</code></pre>
<h4 id="插入数据">插入数据</h4>
<pre><code class="language-mysql">insert into 表名 (name, path, count, firstName, firstMD5, secondName, secondMD5, thirdName, thirdMD5) VALUES ('test', 'test', 1, 'name1', 'md1', 'name2', 'md2', 'name3', 'md3');
</code></pre>
<h4 id="查询表中数据">查询表中数据</h4>
<pre><code class="language-mysql">select * from 表名;

select * from 表名 where name = 'test';

select * from 表名 order by id limit 0,2;
</code></pre>
<h4 id="查询数据库中重复数据">查询数据库中重复数据</h4>
<pre><code class="language-mysql">select firstMD5, count(*) as count from 表名 group by 列名 having count &gt; 1;
</code></pre>
<h4 id="查询重复数据的其他字段数据">查询重复数据的其他字段数据</h4>
<pre><code class="language-mysql">select folderName, path, firstMD5 from 表名 where 列名1 in (select 列名1 from 表名 group by 列名1 having count(列名1) &gt; 1);
</code></pre>
<h4 id="更新数据">更新数据</h4>
<pre><code class="language-mysql">update 表名 set folderName ='Mary' where id=1;
</code></pre>
<h4 id="删除数据">删除数据</h4>
<pre><code class="language-mysql">delete from 表名 where folderName = 'test';
</code></pre>
<h3 id="数据表字段操作">数据表字段操作</h3>
<h4 id="添加字段">添加字段</h4>
<pre><code class="language-mysql">alter table 表名 add id int auto_increment not null primary key;
</code></pre>
<h4 id="修改字段的顺序">修改字段的顺序</h4>
<pre><code class="language-mysql">ALTER TABLE 表名 MODIFY 字段名1 数据类型 FIRST ｜ AFTER 字段名2;
其中：

字段名1：表示需要修改位置的字段的名称。
数据类型：表示“字段名1”的数据类型。
FIRST：指定位置为表的第一个位置。
AFTER 字段名2：指定“字段名1”插入在“字段名2”之后。

alter table MIFit_Image modify id int first;

alter table MIFit_Image modify id int after name;
</code></pre>
<h4 id="移除id主键标志">移除id主键标志</h4>
<pre><code class="language-mysql">alter table 表名 modify id int, drop primary key;
</code></pre>
<h4 id="修改字段名">修改字段名</h4>
<pre><code class="language-mysql">alter table 表名 change name folderName char(100);
</code></pre>
<h4 id="删除字段">删除字段</h4>
<pre><code class="language-mysql">alter table testTable drop folderName;
</code></pre>
<h4 id="加索引">加索引</h4>
<pre><code class="language-mysql"> alter table 表名 add index indexName (folderName);
</code></pre>
<h4 id="删除索引">删除索引</h4>
<pre><code class="language-mysql">alter table 表名 drop index indexName;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DAO层、Service层和Controller层的区别]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/dao-ceng-service-ceng-he-controller-ceng-de-qu-bie/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/dao-ceng-service-ceng-he-controller-ceng-de-qu-bie/">
        </link>
        <updated>2020-12-22T12:43:10.000Z</updated>
        <content type="html"><![CDATA[<img src="https://img-blog.csdnimg.cn/20200710212510979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phcnZhbjU=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />
<h2 id="dao层">DAO层</h2>
<p>DAO层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说某个DAO一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作，建议DAO只做原子操作，增删改查。</p>
<h2 id="service层">Service层</h2>
<p>Service层叫服务层，被称为服务，粗略的理解就是对一个或多个DAO进行的再次封装，封装成一个服务，所以这里也就不会是一个原子操作了，需要事物控制。</p>
<h2 id="controller层">Controller层</h2>
<p>Controler负责请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。</p>
<h2 id="小结">小结</h2>
<p>DAO面向表，Service面向业务。</p>
<p>后端开发时先数据库设计出所有表，然后对每一张表设计出DAO层，然后根据具体的业务逻辑进一步封装DAO层成一个Service层，对外提供成一个服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Code Smell]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/code-smell/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/code-smell/">
        </link>
        <updated>2020-11-24T13:43:34.000Z</updated>
        <content type="html"><![CDATA[<p>Code Smell中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种smell（异味）在代码中追捕到问题。</p>
<p>一般包括：</p>
<ul>
<li>**Duplicated Code(重复的代码)：**代码重复几乎是最常见的异味了。他也是Refactoring 的主要目标之一。代码重复往往来自于copy-and-paste 的编程风格。与他相对应OAOO 是一个好系统的重要标志。</li>
<li>**Long method(过长方法)：**它是传统结构化的“遗毒”。一个方法应当具有自我独立的意图，不要把几个意图放在一起，特别注意大类和长方法。</li>
<li>**Large Class(过大的类)：**大类就是你把太多的责任交给了一个类。这里的规则是One Class One。</li>
<li>**Long Parameter List(过长参数列)：**一个方法有超过三四个的参数。</li>
<li>**Divergent Change(发散式修改)：**一个类里面的内容变化率不同。某些状态一个小时变一次，某些则几个月一年才变一次；某些状态因为这方面的原因发生变化，而另一些则因为其他方面的原因变一 次。面向对象的抽象就是把相对不变的和相对变化相隔离。把问题变化的一方面和另一方面相隔离。这使得这些相对不变的可以重用。问题变化的每个方面都可以单 独重用。这种相异变化的共存使得重用非常困难。</li>
<li>**Shotgun Surgery(霰弹式改动)：**这正好和上面相反。对系统一个地方的改变涉及到其他许多地方的相关改变。这些变化率和变化内容相似的状态和行为通常应当放在同一个类中。</li>
<li>**Feature Envy(依恋情结)：**对象的目的就是封装状态以及与这些状态紧密相关的行为。如果一个类的方法频繁用get 方法存取其他类的状态进行计算，那么你要考虑把行为移到涉及状态数目最多的那个类。</li>
<li>**Data Clumps(数据泥团)：**某些数据通常像孩子一样成群玩耍：一起出现在很多类的成员变量中，一起出现在许多方法的参数中……，这些数据或许应该自己独立形成对象。</li>
<li>**Primitive Obsession(基本类型偏执)：**面向对象的新手通常习惯使用几个原始类型的数据来表示一个概念。譬如对于范围，他们会使用两个数字。对于Money，他们会用一个浮点数来表示。因为你没 有使用对象来表达问题中存在的概念，这使得代码变的难以理解，解决问题的难度大大增加。好的习惯是扩充语言所能提供原始类型，用小对象来表示范围、金额、 转化率、邮政编码等等。</li>
<li>**Switch Statements(switch惊悚现身)：**基于常量的开关语句是OO 的大敌，你应当把他变为子类、state 或strategy。</li>
<li>**Parallel Inheritance Hierarchies(平等继承体系)：**并行的继承层次是shotgun surgery 的特殊情况。因为当你改变一个层次中的某一个类时，你必须同时改变另外一个层次的并行子类。</li>
<li>**Lazy Class(冗赘类)：**一个干活不多的类。类的维护需要额外的开销，如果一个类承担了太少的责任，应当消除它。</li>
<li>**Speculative Generality(夸夸其谈未来性)：**一个类实现了从未用到的功能和通用性。通常这样的类或方法唯一的用户是test case。不要犹豫，删除它。</li>
<li>**Temporary Field(令人迷惑的临时字段)：**一个对象的属性可能只在某些情况下才有意义。这样的代码将难以理解。专门建立一个对象来持有这样的孤儿属性，把只和他相关的行为移到该类。最常见的是一个特定的算法需要某些只有该算法才有用的变量。</li>
<li>**Message Chains(过度耦合的消息链)：**消息链发生于当一个客户向一个对象要求另一个对象，然后客户又向这另一对象要求另一个对象，再向这另一个对象要求另一个对象，如此如此。这时，你需要隐藏分派。</li>
<li>**Middle Man(中间转手人)：**对象的基本特性之一就是封装，而你经常会通过分派去实现封装。但是这一步不能走得太远，如果你发现一个类接口的一大半方法都在做分派，你可能需要移去这个中间人。</li>
<li>**Inappropriate Intimacy(狎昵关系)：**某些类相互之间太亲密，它们花费了太多的时间去砖研别人的私有部分。对人类而言，我们也许不应该太假正经，但我们应当让自己的类严格遵守禁欲主义。</li>
<li>**Alternative Classes with Different Interfaces(异曲同工的类)：**做相同事情的方法有不同的函数signature，一致把它们往类层次上移，直至协议一致。</li>
<li>**Incomplete Library Class(不完美的程序类库)：**要建立一个好的类库非常困难。我们大量的程序工作都基于类库实现。然而，如此广泛而又相异的目标对库构建者提出了苛刻的要求。库构建者也不是万能的。有时 候我们会发现库类无法实现我们需要的功能。而直接对库类的修改有非常困难。这时候就需要用各种手段进行Refactoring。</li>
<li>**Data Class(纯稚的数据类)：**对象包括状态和行为。如果一个类只有状态没有行为，那么肯定有什么地方出问题了。</li>
<li>**Refused Bequest(被拒绝的遗赠)：**超类传下来很多行为和状态，而子类只是用了其中的很小一部分。这通常意味着你的类层次有问题。</li>
<li>**Comments(过多的注释)：**经常觉得要写很多注释表示你的代码难以理解。如果这种感觉太多，表示你需要Refactoring。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hashmap和identityhashmap的区别]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/hashmap-he-identityhashmap-de-qu-bie/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/hashmap-he-identityhashmap-de-qu-bie/">
        </link>
        <updated>2020-10-27T13:41:01.000Z</updated>
        <content type="html"><![CDATA[<p>IdentityHashMap利用Hash表来实现Map接口，比较键（和值）时使用引用相等性代替对象相等性，也就是说使用 <code>==</code> 而不是使用 <code>equals</code>。</p>
<p>比如对于要保存的key，k1和k2，当且仅当k1== k2的时候，IdentityHashMap才会相等，而对于HashMap来说，相等的条件则是：(k1<mark>null ? k2</mark>null : k1.equals(k2))。</p>
<p>IdentityHashMap不是Map的通用实现，它有意违反了Map的常规协定。并且IdentityHashMap允许key和value都为null。</p>
<h2 id="代码示例">代码示例</h2>
<h3 id="对象类">对象类</h3>
<pre><code class="language-java">package testingTutorial;

public class Student {

	private int id = 0;
	private String firstName = null;
	private String name = &quot;&quot;;
	
	public Student(int id, String firstName, String name) {
		super();
		this.id = id;
		this.firstName = firstName;
		this.name = name;
	}
	
	public Student() {
		super();
	}
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((firstName == null) ? 0 : firstName.hashCode());
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (firstName == null) {
			if (other.firstName != null)
				return false;
		} else if (!firstName.equals(other.firstName))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return &quot;Student [id=&quot; + id + &quot;, firstName=&quot; + firstName + &quot;, name=&quot;
				+ name + &quot;]&quot;;
	}
	

}

</code></pre>
<h3 id="hashmap">hashmap</h3>
<pre><code class="language-java">public void testhash(){
        Student alex = new Student(1,&quot;alex&quot;,&quot;a&quot;);
        Student bob = new Student(1,&quot;alex&quot;,&quot;a&quot;);
        Map&lt;Student,Integer&gt; hashmap = new HashMap&lt;&gt;();
        hashmap.put(alex,1);
        hashmap.put(bob,2);
        System.out.println(hashmap.get(alex));
        System.out.println(hashmap.get(bob));
        assertEquals(hashmap.get(alex),hashmap.get(bob));
    }
</code></pre>
<p>测试结果：</p>
<pre><code>2
2
</code></pre>
<p>可以看出hashmap中使用equals()来进行比较，所以put(bob,2)会把alex的value覆盖掉，因为二者key相同，就认为他们是同一个对象。</p>
<h3 id="identityhashmap">identityhashmap</h3>
<pre><code class="language-java">public void testidentityhash() {
            Student alex = new Student(1,&quot;alex&quot;,&quot;a&quot;);
            Student bob = new Student(1,&quot;alex&quot;,&quot;a&quot;);
            Map&lt;Student,Integer&gt; identityHashMap = new IdentityHashMap&lt;&gt;();
            identityHashMap.put(alex,1);
            identityHashMap.put(bob,2);
            System.out.println(identityHashMap.get(alex));
            System.out.println(identityHashMap.get(bob));
            assertEquals(identityHashMap.get(alex),identityHashMap.get(bob));
        }
</code></pre>
<p>测试结果：</p>
<pre><code class="language-java">1
2

junit.framework.AssertionFailedError: 
Expected :1
Actual   :2
</code></pre>
<p>identityhashmap是用==比较内存地址，alex和bob对应的内存地址不同，所以会认为是两个不同的对象。</p>
<h2 id="总结">总结</h2>
<p>IdentityHashMap的==操作是比较的内存地址，如果不是指向同一块内存，那这时候才可以保存相同的数据</p>
<p>IdentityHashMap的hash的计算没有使用Object的hashCode方法，而是使用的System.identityHashCode方法，这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。</p>
<p>IdentityHashMap的实现不同于HashMap，虽然也是数组，不过IdentityHashMap中没有用到链表，解决冲突的方式是计算下一个有效索引，并且将数据key和value紧挨着存在map中，即table[i]=key，那么table[i+1]=value。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇偶校验、海明校验和CRC冗余校验]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/qi-ou-xiao-yan-hai-ming-xiao-yan-he-crc-rong-yu-xiao-yan/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/qi-ou-xiao-yan-hai-ming-xiao-yan-he-crc-rong-yu-xiao-yan/">
        </link>
        <updated>2020-10-26T11:30:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="奇偶校验">奇偶校验</h2>
<h3 id="两种校验规则">两种校验规则</h3>
<p>奇校验——使完整编码（有效位和校验位）中的&quot;1&quot;的个数为奇数个；</p>
<p>偶校验——使完整编码（有效位和校验位）中的&quot;1&quot;的个数为偶数个；</p>
<h3 id="示例">示例</h3>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>奇校验码</th>
<th>偶校验码</th>
</tr>
</thead>
<tbody>
<tr>
<td>1011101</td>
<td>10111010</td>
<td>10111011</td>
</tr>
<tr>
<td>1000111</td>
<td>10001111</td>
<td>10001110</td>
</tr>
</tbody>
</table>
<p>奇偶校验实际上就是对我们DnDn-1...D0进行<strong>异或运算</strong>（两两相同为0，不同为1），最后<strong>偶校验生成0，奇校验生成1，正确，反之错误。</strong></p>
<h2 id="海明校验">海明校验</h2>
<h3 id="概述">概述</h3>
<p>海明码是在原数据中的一些固定位置，插入一位奇（或偶）校验位，虽然使原数据变长，但可使其拥有纠错能力。<br>
能侦测并更正一个比特的错误；若有两个比特出错，则只能侦测，不能更正；若有三个或更多的比特出错，则不能侦测，更不能更正。</p>
<h3 id="示例-2">示例</h3>
<h4 id="校验位和数据位的位置">校验位和数据位的位置</h4>
<table>
<thead>
<tr>
<th>海明码中的位置</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td>2^1</td>
<td>数据</td>
<td>2^2</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^3</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^4</td>
<td>数据</td>
</tr>
<tr>
<td>海明码的值</td>
<td style="text-align:center"></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>海明码中，2的幂位都是校验位，其余为数据位。</p>
<h4 id="计算校验位的值">计算校验位的值</h4>
<table>
<thead>
<tr>
<th style="text-align:left">海明码中的位置</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th>7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
<th style="text-align:center">17</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td style="text-align:center">2^1</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">2^2</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td>数据</td>
<td style="text-align:center">2^3</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">2^4</td>
<td style="text-align:center">数据</td>
</tr>
<tr>
<td style="text-align:left">海明码的值</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td>1</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R1校验</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">参与R2校验</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R4校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R8校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R16校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>位置为Rx的检验位，是从第x位开始（即从Rx开始），检验x位，跳过x位，再检验x位，在跳过x位，以此类推。</p>
<p>R1 = 偶校验(R1, 1, 1, 1, 0) = 1<br>
R2 = 偶校验(R2, 1, 0, 1) = 0<br>
R4 = 偶校验(R4, 1, 0, 1) = 0<br>
R8 = 偶校验(R8, 0) = 0</p>
<p><strong>计算结果：</strong></p>
<table>
<thead>
<tr>
<th>海明码中的位置</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td>2^1</td>
<td>数据</td>
<td>2^2</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^3</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^4</td>
<td>数据</td>
</tr>
<tr>
<td>海明码的值</td>
<td style="text-align:center">1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>得到的海明码为：101010100</p>
<h4 id="检测和更正">检测和更正</h4>
<p>首先，按照编码的方式（奇校验或偶校验），依次检测校验位R1、R2、R4、R8……，然后，将出错的校验位的位置相加，比如发现R1、R8出现错误，则将1和8相加，得到9，即为位置D9的比特出错，最后，将该错误的比特取反就能更正错误。</p>
<h5 id="示例-3">示例</h5>
<p>如果上文中得出的校验码出错，变为“101010101”。</p>
<p><strong>1.检测校验位</strong></p>
<p>该海明码使用教研方式是偶校验，所以我们检验校验位时，也要使用偶校验。<br>
R1 = 偶校验(R1, 1, 1, 1, 0) = 1 出错<br>
R2 = 偶校验(R2, 1, 0, 1) = 0 正确<br>
R4 = 偶校验(R4, 1, 0, 1) = 0 正确<br>
R8 = 偶校验(R8, 0) = 0 错误</p>
<p><strong>2.确定出错的位置</strong></p>
<p>出错比特的位置 = R1的位置是1 + R8的位置是8 = 9</p>
<p><strong>3.更正错误</strong></p>
<p>把第九位取反</p>
<h2 id="crc冗余校验">CRC冗余校验</h2>
<h3 id="基本原理">基本原理</h3>
<p>CRC检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码(序列)，从而构成一个总长为n＝p＋r位的二进制序列</p>
<h3 id="基本概念">基本概念</h3>
<p>1、帧检验序列FCS（Frame Check Sequence）：为了进行差错检验而添加的冗余码。</p>
<p>2、多项式模2运算：实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。如：10011011 + 11001010 = 01010001。</p>
<p>3、生成多项式（generator polynomial）：当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作G（x）。生成多项式的最高位与最低位必须是1。常用的CRC码的生成多项式有：</p>
<p>CRC8=X8+X5+X4+1</p>
<p>每一个生成多项式都可以与一个代码相对应，如CRC8对应代码：100110001。</p>
<h3 id="示例-4">示例</h3>
<p>信息字段为K位，校验字段为R位，则码字长度为N(N=K+R)</p>
<p>设需要发送的信息为M = 1010001101，G（x）= x5+x4+x2+1,则多项式产生的对应代码为110101，R=5。则在M后面添加5个0，对P进行模二除法运算，得余数r(x)对应的代码：01110。故实际需要发送的数据是101000110101110。</p>
<img src="http://b34.photo.store.qq.com/http_imgload.cgi?/rurl4_b=ab7548a2157c272582205d4d7d2e2dbc535ad00f42244c51bc0b8087071c10c2683af72c72a71662a3c38b1ec09a258a88f288a64ddcf8f829e73fbb90cac9a7a7a2d749f09f2bdcabb97c2ab582ad46953b0e65&amp;a=34&amp;b=34" alt="img" style="zoom:50%;" />
<h3 id="差错检测">差错检测</h3>
<p>当接收方收到数据后，用收到的数据对P（事先约定的）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Velocity和XmlDecoder]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/velocity-he-xmldecoder/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/velocity-he-xmldecoder/">
        </link>
        <updated>2020-10-23T13:03:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>展示层有三大典型技术，分别是JSP、freemaker和velocity。</p>
<p>Velocity是一个基于Java的模板引擎，通过特定的语法，Velocity可以获取在java语言中定义的对象，从而实现界面和java代码的真正分离，这意味着可以使用velocity替代jsp的开发模式了。这使得前端开发人员可以和 Java 程序开发人员同步开发一个遵循 MVC 架构的 web 站点。</p>
<h2 id="maven依赖">MAVEN依赖</h2>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity&lt;/artifactId&gt;
    &lt;version&gt;1.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="使用velocity">使用Velocity</h2>
<h3 id="初始化velocity引擎">初始化Velocity引擎</h3>
<pre><code class="language-java">public static void main(String[] args) {
        try {
            //读取xml文档
            XMLDecoder d = new XMLDecoder(
                    new BufferedInputStream(
                            new FileInputStream(&quot;friends.xml&quot;)));
            ArrayList&lt;Person&gt; result = (ArrayList&lt;Person&gt;) d.readObject();
//            System.out.println(result.get(0).getFirstName());
            d.close();

            //初始化模板引擎
            VelocityEngine ve = new VelocityEngine();
            ve.setProperty(RuntimeConstants.RESOURCE_LOADER,&quot;classpath&quot;);
            ve.setProperty(&quot;classpath.resource.loader.class&quot;, ClasspathResourceLoader.class.getName());
            ve.init();
            //获取模板文件
            Template t = ve.getTemplate(&quot;data.vm&quot;);
            FileOutputStream outputfile = new FileOutputStream(&quot;invitations.txt&quot;);
            VelocityContext ctx = new VelocityContext();
            for (int i = 0; i &lt; 8; i++) {
                String fname = result.get(i).getFirstName();
                String name = result.get(i).getName();
                int addressnumber = result.get(i).getAddress().getNumber();
                String addressstreet = result.get(i).getAddress().getStreet();
                String addresstown = result.get(i).getAddress().getTown();
                ctx.put(&quot;fname&quot;,fname);
                ctx.put(&quot;name&quot;,name);
                ctx.put(&quot;addressnumber&quot;,addressnumber);
                ctx.put(&quot;addressstreet&quot;,addressstreet);
                ctx.put(&quot;addresstown&quot;,addresstown);
                StringWriter sw = new StringWriter();
                t.merge(ctx,sw);
//                System.out.println(sw.toString());
                outputfile.write(sw.toString().getBytes(&quot;UTF-8&quot;));
            }


        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
</code></pre>
<h3 id="xml文件">xml文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;java version=&quot;1.8.0_261&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
 &lt;object class=&quot;java.util.ArrayList&quot;&gt;
  &lt;void method=&quot;add&quot;&gt;
   &lt;object class=&quot;templatesTutorial.Person&quot;&gt;
    &lt;void property=&quot;address&quot;&gt;
     &lt;object class=&quot;templatesTutorial.Address&quot;&gt;
      &lt;void property=&quot;number&quot;&gt;
       &lt;int&gt;100&lt;/int&gt;
      &lt;/void&gt;
      &lt;void property=&quot;street&quot;&gt;
       &lt;string&gt;Main Street&lt;/string&gt;
      &lt;/void&gt;
      &lt;void property=&quot;town&quot;&gt;
       &lt;string&gt;Palmerston North&lt;/string&gt;
      &lt;/void&gt;
     &lt;/object&gt;
    &lt;/void&gt;
    &lt;void property=&quot;firstName&quot;&gt;
     &lt;string&gt;Tim&lt;/string&gt;
    &lt;/void&gt;
    &lt;void property=&quot;name&quot;&gt;
     &lt;string&gt;MacDonald&lt;/string&gt;
    &lt;/void&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;/object&gt;
&lt;/java&gt;
</code></pre>
<h3 id="编写vm文件">编写.vm文件</h3>
<pre><code>To
$fname $name
$addressnumber $addressstreet
$addresstown

Dear $fname,

I would like to invite you to a party this Saturday, 8PM at my place.

Cheers, me

----------------------------------------------------------------
</code></pre>
<p>输出：</p>
<pre><code>To
Tim MacDonald
100 Main Street
Palmerston North

Dear Tim,

I would like to invite you to a party this Saturday, 8PM at my place.

Cheers, me

----------------------------------------------------------------
</code></pre>
<h2 id="velocity的基本语法">Velocity的基本语法</h2>
<h3 id="变量">变量</h3>
<pre><code class="language-velocity">#set($name =“velocity”)
#set($hello =“hello $name”)
</code></pre>
<p>上面的这个等式将会给 $hello 赋值为“hello velocity”</p>
<h3 id="循环">循环</h3>
<p>在 Velocity 中循环语句的语法结构如下：</p>
<pre><code class="language-velocity">#foreach($element in $list)
 This is $element
 $velocityCount
#end
</code></pre>
<p>Velocity 引擎会将 list 中的值循环赋给 element 变量，同时会创建一个 $velocityCount 的变量作为计数，从 1 开始，每次循环都会加 1.</p>
<h3 id="条件语句">条件语句</h3>
<p>语法：</p>
<pre><code class="language-velocity">#if(condition)
#elseif(condition)
#else
#end
</code></pre>
<h3 id="关系操作符">关系操作符</h3>
<p>Velocity 引擎提供了 AND、OR 和 NOT 操作符，分别对应&amp;&amp;、||和! 例如：</p>
<pre><code class="language-velocity">#if($foo &amp;&amp; $bar)
#end
#if($foo || $bar)
#end
#if(!$foo)
#end
</code></pre>
<h3 id="宏">宏</h3>
<p>Velocity 中的宏可以理解为函数定义。定义的语法如下：</p>
<pre><code class="language-velocity">#macro(macroName arg1 arg2 …)
#end
</code></pre>
<p>调用这个宏的语法是：</p>
<pre><code class="language-velocity">#macroName(arg1 arg2 …)
</code></pre>
<p>这里的参数之间使用空格隔开，下面是定义和使用 Velocity 宏的例子：</p>
<pre><code class="language-velocity">#macro(sayHello $name)
hello $name
#end
</code></pre>
<pre><code class="language-velocity">#sayHello(“velocity”)
</code></pre>
<p>输出：hello velocity</p>
<h3 id="parse和include指令">parse和include指令</h3>
<p>在Velocity中可以通过parse或者include指令引入外部vm文件，但是二者存在区别：include指令会将外部文件原样输出，而parse指令会先对其进行解析再输出(即对外部文件中的vm语法解析)</p>
<pre><code class="language-velocity">#parse(&quot;header.vm&quot;)
#include(&quot;footer.vm&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pandas库loc和iloc]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/pandas-ku-loc-he-iloc/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/pandas-ku-loc-he-iloc/">
        </link>
        <updated>2020-10-19T14:59:34.000Z</updated>
        <content type="html"><![CDATA[<p>loc是指location的意思，iloc中的i是指integer</p>
<p>loc是根据index来索引。</p>
<p>iloc并不是根据index来索引，而是根据行号来索引，行号从0开始，逐次加1,并且只能用整数来取数。</p>
<h3 id="loc的使用">loc的使用</h3>
<p><strong>loc</strong>：loc的使用范围要远高于iloc, loc也能够做到iloc的切片取数, 除了df.loc[-1]</p>
<p><strong>使用情况</strong>：使用切片、索引、列名称查找，按条件(bool)查找</p>
<p><strong>数据源</strong>：</p>
<pre><code class="language-python">&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],
...      index=['A', 'B', 'C'],
...      columns=['col1', 'col2'])

          col1   col2
A          1       2
B          4       5
C          7       8
</code></pre>
<p><strong>用法示例</strong>：</p>
<p>（1）单独标签，返回一个单独的series</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['A']
col1  1
col2  2
</code></pre>
<p>（2）内嵌List，返回一个DataFrame</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['B','C']
          col1   col2
A          1       2
C          7       8
</code></pre>
<p>（3）Single label for row and column，注意，先索引，再列名</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['B','col2']
5
</code></pre>
<p>（4）多个索引加列名</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['A':'C','col2']
A  2
C  8
</code></pre>
<p>（5）用布尔值：针对行进行过滤。False表示不取这一行。True表示取出这一行</p>
<pre><code class="language-PYTHON">&gt;&gt;&gt; df.loc[[FALSE,FALSE,TRUE]]
          col1   col2
C          7       8
</code></pre>
<p>（6）条件判断</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc[df['col1'] &gt; 6]
          col1   col2
C          7       8

&gt;&gt;&gt; df.loc[df['col1'] &gt; 6,['col1']]
          col1   
C          7      

&gt;&gt;&gt; df.loc[lambda df: df['col2'] == 8]
          col1   col2
C          7       8
</code></pre>
<p>7）设置值：选中某些值；整行；整列</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc[['A','B'],['col2']] == 20
          col1   col2
A          1       20
B          4       20
C          7       8

&gt;&gt;&gt; df.loc['C'] == 10
          col1   col2
A          1       20
B          4       20
C          10       10

&gt;&gt;&gt; df.loc[:,'col1'] == 30
          col1   col2
A          30       20
B          30       20
C          30       10
</code></pre>
<h3 id="iloc的使用">iloc的使用</h3>
<p><strong>iloc</strong>: i可以看着Integer,因此iloc就是用整数(Integer)来取数据的.</p>
<p><strong>使用情况</strong>：使用整数通过切片等方式取数</p>
<p><strong>用法示例</strong>：</p>
<pre><code class="language-python"># 切片
# 下面两种方法有同样的效果; 表示取出df中1：5行(不包括5)和3：6列
df.iloc[1:5,3:6] 
df.iloc[[1,2,3,4],[3,4,5]] 
# 另外 df.iloc[0]、df.iloc[1]、df.iloc[-1] 分别表示第一行、第二行、最后一行
# 同理df.iloc[:,0]、df.iloc[:,1]、df.iloc[:,-1] 分别表示第一列、第二列、最后一列
</code></pre>
<h3 id="总结">总结</h3>
<ul>
<li>loc使用范围比iloc更广更实用，loc可以使用切片、名称(index,columns)、也可以切片和名称混合使用；但是loc不能使用不存在的索引来充当切片取值,像-1。</li>
<li>iloc只能用整数来取数。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何解决failed to push some refs to git]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/ru-he-jie-jue-failed-to-push-some-refs-to-git/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/ru-he-jie-jue-failed-to-push-some-refs-to-git/">
        </link>
        <updated>2020-10-01T16:00:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="错误信息">错误信息</h3>
<p>在使用git 对源代码进行push到gitHub时可能会出错，例如</p>
<figure data-type="image" tabindex="1"><img src="https://zzddl.github.io/zdl.github.io//post-images/1601568150391.jpg" alt="" loading="lazy"></figure>
<h3 id="错误原因">错误原因</h3>
<p>出现错误的主要原因是github中的README.md文件不在本地代码目录中</p>
<h3 id="解决办法">解决办法</h3>
<p>执行命令<strong>git pull --rebase origin master</strong></p>
<p>**注：**pull=fetch+merge</p>
<p>执行代码后可以在本地看到README.md文件</p>
<p>此时再执行语句 git push -u origin master即可完成代码上传到github</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STM32 位绑定操作]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/stm32-wei-bang-ding-cao-zuo/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/stm32-wei-bang-ding-cao-zuo/">
        </link>
        <updated>2020-09-08T02:13:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定义">定义</h3>
<p>STM32将寄存器映射到了位绑定区（bit_band region），这样就可以通过统一的线性寻址空间直接操作寄存器了，这个空间就是0x00000000~0xFFFF FFFF共4GB大小，除去寄存器外，其他包括程序存储区、数据存储区、输入输出端口等。</p>
<h3 id="支持位绑定操作的两个内存区">支持位绑定操作的两个内存区</h3>
<p>0x2000 0000~0x200F FFFF（SRAM区中最低1MB）</p>
<p>0x4000 0000~0x400F FFFF（片上外设区中最低1MB）</p>
<h3 id="位绑定操作的理解">位绑定操作的理解</h3>
<p>CPU是32位的，最方便快捷的是直接操作一个32位的地址，比如0x4200 ABCD这样，对这个地址赋值是最快捷的操作，只要一条指令。于是STM32又设计出别名区（Alias region）的概念，将一个32位地址空间对应到位带区（bit_band region）中的一个位。32位是STM32 CPU能独立访问的地址空间（称为字，即4个字节），将这个地址空间的起始位（bit0，其他bit1~bit31忽略）内容设为0或1就等于对位带区的相应位进行了操作，也相当于对寄存器进行了操作。</p>
<p>映射关系：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20170214140941826" alt="img" loading="lazy"></figure>
<p>位绑定别名区一共有两个，每一个都是32MB，是位绑定区1MB的32倍，因为位绑定区是以位为单位，每8位有一个地址，位绑定别名区是以字为单位，一个字等于四个字节32位字长。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20170214140948727" alt="img" loading="lazy"></figure>
<p>位绑定区0x2000 0000的第0位对应别名区地址0x22000000~0x2200 0003这4个字节，需要指出的是0x2200 0001、0x2200 0002、0x2200 0003这样的地址是不能直接被访问的，只有0x2200 0000、0x2200 0004、0x2200 0008…这样的起始地址（其实是4的倍数）才能被访问</p>
<p><strong>别名区的地址映射就是计算起始地址</strong></p>
<p>STM32别名区起始地址的计算：</p>
<p>it_word_addr = bit_band_base + (byte_offset * 32) +(bit_number * 4)</p>
<ul>
<li>bit_word_addr：是位绑定区目标位映射到别名区的字的起始地址</li>
<li>bit_band_base：是别名区的起始地址</li>
<li>byte_offset：是位带区包含目标位的字节的地址偏移量。</li>
<li>byte_offset * 32：是因为位带区的一个位要扩张到别名区的32个位，同样，一个位带区的地址也会扩张到别名区的32个地址。byte_offset * 32表示前面已经占用的地址。</li>
<li>bit_number：是目标位所在的位的位置（0-7）</li>
<li>bit_number*4是因为 1bit位要占用四个地址单元（四个字节，32 bit位）</li>
</ul>
<p>公式的变形：</p>
<p>it_word_addr = bit_band_base + ((byte_offset * 8) + bit_number) * 4</p>
<p>由于位绑定区每一个地址是8位，所以(byte_offset * 8)+ bit_number相当计算出了一个以字节为单位的偏移，再乘以4就是以字为单位的偏移了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大泥球（Big Ball of Mud）]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/">
        </link>
        <updated>2020-09-01T07:35:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义：</h2>
<p>大泥球是指一个随意化的杂乱的结构化系统，只是代码的堆砌和拼凑，往往会导致很多错误或者缺陷。</p>
<h2 id="缺点">缺点：</h2>
<p>无法使得系统内的信息得到更好的控制和共享，使得信息失去了应有的价值。大泥球般的系统的整体结构没有得到很好的界定，也就使得大泥球越发的复杂和杂乱无章。最终会使得这个系统的代码不被程序员理解，更无法对其修复，无法满足用户的需求变化。</p>
<h2 id="产生的原因">产生的原因：</h2>
<p>首先，程序员在编写程序或是系统时遇到问题后的解决方法，往往不是合适的或者最优的解法，而是方便修改的，变动最小的，这就为以后的系统架构的混乱甚至整个系统的奔溃埋下了隐患。其次，用户的需求或者编程的要求是在不断地变化的，任何一个已有的系统都随之会产生重大的变化，使得系统越来越复杂化，维护也越来越昂贵，另外编写人员的变动等等因素都会导致系统的退化，一步步变为大泥球。</p>
<p>所以，可以将其产生的原因归结为：一次性代码，碎片式增长，缺少前期设计，应对需求和架构变化过晚，程序员的经验，技巧，眼界的限制。</p>
<h2 id="避免或者修改大泥球的方法">避免或者修改大泥球的方法：</h2>
<p>首先，程序员或者设计师为了在预算中并按时交付高质量的软件，就需要关注软件的特性和功能，然后集中在架构和性能，使得软件设计初步就避免产生小的问题或者方向的偏差。其次，程序员在编写软件时要及时的解决出现的小问题或者原型概念等等，这样不会使得问题堆积导致后期的无法修改。另外，应当及时处理用户需求的变化，由于需求往往会随着时间的推移而变化，所以应当逐步的解决，并且鼓励和积极面对变化而不是掩盖问题。另外，要保持一直工作的状态，不断地维护需求和系统。但不应当进行一次彻底的检查，这样很可能会破坏系统。当然，软件系统也是在变化的，但是不同的部分会以不同的速度变化，所以应当使得它们的变化率一致。最坏的结果就是代码已经下降到了无法修复甚至理解的地步，那么就扔掉，重新开始。</p>
]]></content>
    </entry>
</feed>