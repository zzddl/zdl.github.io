<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzddl.github.io/zdl.github.io/</id>
    <title>zdl&apos;s blog</title>
    <updated>2020-11-06T14:03:31.956Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzddl.github.io/zdl.github.io/"/>
    <link rel="self" href="https://zzddl.github.io/zdl.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzddl.github.io/zdl.github.io/images/avatar.png</logo>
    <icon>https://zzddl.github.io/zdl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zdl&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[hashmap和identityhashmap的区别]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/hashmap-he-identityhashmap-de-qu-bie/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/hashmap-he-identityhashmap-de-qu-bie/">
        </link>
        <updated>2020-10-27T13:41:01.000Z</updated>
        <content type="html"><![CDATA[<p>IdentityHashMap利用Hash表来实现Map接口，比较键（和值）时使用引用相等性代替对象相等性，也就是说使用 <code>==</code> 而不是使用 <code>equals</code>。</p>
<p>比如对于要保存的key，k1和k2，当且仅当k1== k2的时候，IdentityHashMap才会相等，而对于HashMap来说，相等的条件则是：(k1<mark>null ? k2</mark>null : k1.equals(k2))。</p>
<p>IdentityHashMap不是Map的通用实现，它有意违反了Map的常规协定。并且IdentityHashMap允许key和value都为null。</p>
<h2 id="代码示例">代码示例</h2>
<h3 id="对象类">对象类</h3>
<pre><code class="language-java">package testingTutorial;

public class Student {

	private int id = 0;
	private String firstName = null;
	private String name = &quot;&quot;;
	
	public Student(int id, String firstName, String name) {
		super();
		this.id = id;
		this.firstName = firstName;
		this.name = name;
	}
	
	public Student() {
		super();
	}
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((firstName == null) ? 0 : firstName.hashCode());
		result = prime * result + id;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (firstName == null) {
			if (other.firstName != null)
				return false;
		} else if (!firstName.equals(other.firstName))
			return false;
		if (id != other.id)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return &quot;Student [id=&quot; + id + &quot;, firstName=&quot; + firstName + &quot;, name=&quot;
				+ name + &quot;]&quot;;
	}
	

}

</code></pre>
<h3 id="hashmap">hashmap</h3>
<pre><code class="language-java">public void testhash(){
        Student alex = new Student(1,&quot;alex&quot;,&quot;a&quot;);
        Student bob = new Student(1,&quot;alex&quot;,&quot;a&quot;);
        Map&lt;Student,Integer&gt; hashmap = new HashMap&lt;&gt;();
        hashmap.put(alex,1);
        hashmap.put(bob,2);
        System.out.println(hashmap.get(alex));
        System.out.println(hashmap.get(bob));
        assertEquals(hashmap.get(alex),hashmap.get(bob));
    }
</code></pre>
<p>测试结果：</p>
<pre><code>2
2
</code></pre>
<p>可以看出hashmap中使用equals()来进行比较，所以put(bob,2)会把alex的value覆盖掉，因为二者key相同，就认为他们是同一个对象。</p>
<h3 id="identityhashmap">identityhashmap</h3>
<pre><code class="language-java">public void testidentityhash() {
            Student alex = new Student(1,&quot;alex&quot;,&quot;a&quot;);
            Student bob = new Student(1,&quot;alex&quot;,&quot;a&quot;);
            Map&lt;Student,Integer&gt; identityHashMap = new IdentityHashMap&lt;&gt;();
            identityHashMap.put(alex,1);
            identityHashMap.put(bob,2);
            System.out.println(identityHashMap.get(alex));
            System.out.println(identityHashMap.get(bob));
            assertEquals(identityHashMap.get(alex),identityHashMap.get(bob));
        }
</code></pre>
<p>测试结果：</p>
<pre><code class="language-java">1
2

junit.framework.AssertionFailedError: 
Expected :1
Actual   :2
</code></pre>
<p>identityhashmap是用==比较内存地址，alex和bob对应的内存地址不同，所以会认为是两个不同的对象。</p>
<h2 id="总结">总结</h2>
<p>IdentityHashMap的==操作是比较的内存地址，如果不是指向同一块内存，那这时候才可以保存相同的数据</p>
<p>IdentityHashMap的hash的计算没有使用Object的hashCode方法，而是使用的System.identityHashCode方法，这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。</p>
<p>IdentityHashMap的实现不同于HashMap，虽然也是数组，不过IdentityHashMap中没有用到链表，解决冲突的方式是计算下一个有效索引，并且将数据key和value紧挨着存在map中，即table[i]=key，那么table[i+1]=value。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇偶校验、海明校验和CRC冗余校验]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/qi-ou-xiao-yan-hai-ming-xiao-yan-he-crc-rong-yu-xiao-yan/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/qi-ou-xiao-yan-hai-ming-xiao-yan-he-crc-rong-yu-xiao-yan/">
        </link>
        <updated>2020-10-26T11:30:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="奇偶校验">奇偶校验</h2>
<h3 id="两种校验规则">两种校验规则</h3>
<p>奇校验——使完整编码（有效位和校验位）中的&quot;1&quot;的个数为奇数个；</p>
<p>偶校验——使完整编码（有效位和校验位）中的&quot;1&quot;的个数为偶数个；</p>
<h3 id="示例">示例</h3>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>奇校验码</th>
<th>偶校验码</th>
</tr>
</thead>
<tbody>
<tr>
<td>1011101</td>
<td>10111010</td>
<td>10111011</td>
</tr>
<tr>
<td>1000111</td>
<td>10001111</td>
<td>10001110</td>
</tr>
</tbody>
</table>
<p>奇偶校验实际上就是对我们DnDn-1...D0进行<strong>异或运算</strong>（两两相同为0，不同为1），最后<strong>偶校验生成0，奇校验生成1，正确，反之错误。</strong></p>
<h2 id="海明校验">海明校验</h2>
<h3 id="概述">概述</h3>
<p>海明码是在原数据中的一些固定位置，插入一位奇（或偶）校验位，虽然使原数据变长，但可使其拥有纠错能力。<br>
能侦测并更正一个比特的错误；若有两个比特出错，则只能侦测，不能更正；若有三个或更多的比特出错，则不能侦测，更不能更正。</p>
<h3 id="示例-2">示例</h3>
<h4 id="校验位和数据位的位置">校验位和数据位的位置</h4>
<table>
<thead>
<tr>
<th>海明码中的位置</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td>2^1</td>
<td>数据</td>
<td>2^2</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^3</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^4</td>
<td>数据</td>
</tr>
<tr>
<td>海明码的值</td>
<td style="text-align:center"></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>海明码中，2的幂位都是校验位，其余为数据位。</p>
<h4 id="计算校验位的值">计算校验位的值</h4>
<table>
<thead>
<tr>
<th style="text-align:left">海明码中的位置</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th>7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
<th style="text-align:center">17</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td style="text-align:center">2^1</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">2^2</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td>数据</td>
<td style="text-align:center">2^3</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">数据</td>
<td style="text-align:center">2^4</td>
<td style="text-align:center">数据</td>
</tr>
<tr>
<td style="text-align:left">海明码的值</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td>1</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R1校验</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">参与R2校验</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R4校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td>√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R8校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">参与R16校验</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>位置为Rx的检验位，是从第x位开始（即从Rx开始），检验x位，跳过x位，再检验x位，在跳过x位，以此类推。</p>
<p>R1 = 偶校验(R1, 1, 1, 1, 0) = 1<br>
R2 = 偶校验(R2, 1, 0, 1) = 0<br>
R4 = 偶校验(R4, 1, 0, 1) = 0<br>
R8 = 偶校验(R8, 0) = 0</p>
<p><strong>计算结果：</strong></p>
<table>
<thead>
<tr>
<th>海明码中的位置</th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否为2的幂</td>
<td style="text-align:center">2^0</td>
<td>2^1</td>
<td>数据</td>
<td>2^2</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^3</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>数据</td>
<td>2^4</td>
<td>数据</td>
</tr>
<tr>
<td>海明码的值</td>
<td style="text-align:center">1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>得到的海明码为：101010100</p>
<h4 id="检测和更正">检测和更正</h4>
<p>首先，按照编码的方式（奇校验或偶校验），依次检测校验位R1、R2、R4、R8……，然后，将出错的校验位的位置相加，比如发现R1、R8出现错误，则将1和8相加，得到9，即为位置D9的比特出错，最后，将该错误的比特取反就能更正错误。</p>
<h5 id="示例-3">示例</h5>
<p>如果上文中得出的校验码出错，变为“101010101”。</p>
<p><strong>1.检测校验位</strong></p>
<p>该海明码使用教研方式是偶校验，所以我们检验校验位时，也要使用偶校验。<br>
R1 = 偶校验(R1, 1, 1, 1, 0) = 1 出错<br>
R2 = 偶校验(R2, 1, 0, 1) = 0 正确<br>
R4 = 偶校验(R4, 1, 0, 1) = 0 正确<br>
R8 = 偶校验(R8, 0) = 0 错误</p>
<p><strong>2.确定出错的位置</strong></p>
<p>出错比特的位置 = R1的位置是1 + R8的位置是8 = 9</p>
<p><strong>3.更正错误</strong></p>
<p>把第九位取反</p>
<h2 id="crc冗余校验">CRC冗余校验</h2>
<h3 id="基本原理">基本原理</h3>
<p>CRC检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码(序列)，从而构成一个总长为n＝p＋r位的二进制序列</p>
<h3 id="基本概念">基本概念</h3>
<p>1、帧检验序列FCS（Frame Check Sequence）：为了进行差错检验而添加的冗余码。</p>
<p>2、多项式模2运算：实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。如：10011011 + 11001010 = 01010001。</p>
<p>3、生成多项式（generator polynomial）：当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作G（x）。生成多项式的最高位与最低位必须是1。常用的CRC码的生成多项式有：</p>
<p>CRC8=X8+X5+X4+1</p>
<p>每一个生成多项式都可以与一个代码相对应，如CRC8对应代码：100110001。</p>
<h3 id="示例-4">示例</h3>
<p>信息字段为K位，校验字段为R位，则码字长度为N(N=K+R)</p>
<p>设需要发送的信息为M = 1010001101，G（x）= x5+x4+x2+1,则多项式产生的对应代码为110101，R=5。则在M后面添加5个0，对P进行模二除法运算，得余数r(x)对应的代码：01110。故实际需要发送的数据是101000110101110。</p>
<img src="http://b34.photo.store.qq.com/http_imgload.cgi?/rurl4_b=ab7548a2157c272582205d4d7d2e2dbc535ad00f42244c51bc0b8087071c10c2683af72c72a71662a3c38b1ec09a258a88f288a64ddcf8f829e73fbb90cac9a7a7a2d749f09f2bdcabb97c2ab582ad46953b0e65&amp;a=34&amp;b=34" alt="img" style="zoom:50%;" />
<h3 id="差错检测">差错检测</h3>
<p>当接收方收到数据后，用收到的数据对P（事先约定的）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Velocity和XmlDecoder]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/velocity-he-xmldecoder/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/velocity-he-xmldecoder/">
        </link>
        <updated>2020-10-23T13:03:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>展示层有三大典型技术，分别是JSP、freemaker和velocity。</p>
<p>Velocity是一个基于Java的模板引擎，通过特定的语法，Velocity可以获取在java语言中定义的对象，从而实现界面和java代码的真正分离，这意味着可以使用velocity替代jsp的开发模式了。这使得前端开发人员可以和 Java 程序开发人员同步开发一个遵循 MVC 架构的 web 站点。</p>
<h2 id="maven依赖">MAVEN依赖</h2>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity&lt;/artifactId&gt;
    &lt;version&gt;1.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="使用velocity">使用Velocity</h2>
<h3 id="初始化velocity引擎">初始化Velocity引擎</h3>
<pre><code class="language-java">public static void main(String[] args) {
        try {
            //读取xml文档
            XMLDecoder d = new XMLDecoder(
                    new BufferedInputStream(
                            new FileInputStream(&quot;friends.xml&quot;)));
            ArrayList&lt;Person&gt; result = (ArrayList&lt;Person&gt;) d.readObject();
//            System.out.println(result.get(0).getFirstName());
            d.close();

            //初始化模板引擎
            VelocityEngine ve = new VelocityEngine();
            ve.setProperty(RuntimeConstants.RESOURCE_LOADER,&quot;classpath&quot;);
            ve.setProperty(&quot;classpath.resource.loader.class&quot;, ClasspathResourceLoader.class.getName());
            ve.init();
            //获取模板文件
            Template t = ve.getTemplate(&quot;data.vm&quot;);
            FileOutputStream outputfile = new FileOutputStream(&quot;invitations.txt&quot;);
            VelocityContext ctx = new VelocityContext();
            for (int i = 0; i &lt; 8; i++) {
                String fname = result.get(i).getFirstName();
                String name = result.get(i).getName();
                int addressnumber = result.get(i).getAddress().getNumber();
                String addressstreet = result.get(i).getAddress().getStreet();
                String addresstown = result.get(i).getAddress().getTown();
                ctx.put(&quot;fname&quot;,fname);
                ctx.put(&quot;name&quot;,name);
                ctx.put(&quot;addressnumber&quot;,addressnumber);
                ctx.put(&quot;addressstreet&quot;,addressstreet);
                ctx.put(&quot;addresstown&quot;,addresstown);
                StringWriter sw = new StringWriter();
                t.merge(ctx,sw);
//                System.out.println(sw.toString());
                outputfile.write(sw.toString().getBytes(&quot;UTF-8&quot;));
            }


        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }


    }
</code></pre>
<h3 id="xml文件">xml文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;java version=&quot;1.8.0_261&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;
 &lt;object class=&quot;java.util.ArrayList&quot;&gt;
  &lt;void method=&quot;add&quot;&gt;
   &lt;object class=&quot;templatesTutorial.Person&quot;&gt;
    &lt;void property=&quot;address&quot;&gt;
     &lt;object class=&quot;templatesTutorial.Address&quot;&gt;
      &lt;void property=&quot;number&quot;&gt;
       &lt;int&gt;100&lt;/int&gt;
      &lt;/void&gt;
      &lt;void property=&quot;street&quot;&gt;
       &lt;string&gt;Main Street&lt;/string&gt;
      &lt;/void&gt;
      &lt;void property=&quot;town&quot;&gt;
       &lt;string&gt;Palmerston North&lt;/string&gt;
      &lt;/void&gt;
     &lt;/object&gt;
    &lt;/void&gt;
    &lt;void property=&quot;firstName&quot;&gt;
     &lt;string&gt;Tim&lt;/string&gt;
    &lt;/void&gt;
    &lt;void property=&quot;name&quot;&gt;
     &lt;string&gt;MacDonald&lt;/string&gt;
    &lt;/void&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;/object&gt;
&lt;/java&gt;
</code></pre>
<h3 id="编写vm文件">编写.vm文件</h3>
<pre><code>To
$fname $name
$addressnumber $addressstreet
$addresstown

Dear $fname,

I would like to invite you to a party this Saturday, 8PM at my place.

Cheers, me

----------------------------------------------------------------
</code></pre>
<p>输出：</p>
<pre><code>To
Tim MacDonald
100 Main Street
Palmerston North

Dear Tim,

I would like to invite you to a party this Saturday, 8PM at my place.

Cheers, me

----------------------------------------------------------------
</code></pre>
<h2 id="velocity的基本语法">Velocity的基本语法</h2>
<h3 id="变量">变量</h3>
<pre><code class="language-velocity">#set($name =“velocity”)
#set($hello =“hello $name”)
</code></pre>
<p>上面的这个等式将会给 $hello 赋值为“hello velocity”</p>
<h3 id="循环">循环</h3>
<p>在 Velocity 中循环语句的语法结构如下：</p>
<pre><code class="language-velocity">#foreach($element in $list)
 This is $element
 $velocityCount
#end
</code></pre>
<p>Velocity 引擎会将 list 中的值循环赋给 element 变量，同时会创建一个 $velocityCount 的变量作为计数，从 1 开始，每次循环都会加 1.</p>
<h3 id="条件语句">条件语句</h3>
<p>语法：</p>
<pre><code class="language-velocity">#if(condition)
#elseif(condition)
#else
#end
</code></pre>
<h3 id="关系操作符">关系操作符</h3>
<p>Velocity 引擎提供了 AND、OR 和 NOT 操作符，分别对应&amp;&amp;、||和! 例如：</p>
<pre><code class="language-velocity">#if($foo &amp;&amp; $bar)
#end
#if($foo || $bar)
#end
#if(!$foo)
#end
</code></pre>
<h3 id="宏">宏</h3>
<p>Velocity 中的宏可以理解为函数定义。定义的语法如下：</p>
<pre><code class="language-velocity">#macro(macroName arg1 arg2 …)
#end
</code></pre>
<p>调用这个宏的语法是：</p>
<pre><code class="language-velocity">#macroName(arg1 arg2 …)
</code></pre>
<p>这里的参数之间使用空格隔开，下面是定义和使用 Velocity 宏的例子：</p>
<pre><code class="language-velocity">#macro(sayHello $name)
hello $name
#end
</code></pre>
<pre><code class="language-velocity">#sayHello(“velocity”)
</code></pre>
<p>输出：hello velocity</p>
<h3 id="parse和include指令">parse和include指令</h3>
<p>在Velocity中可以通过parse或者include指令引入外部vm文件，但是二者存在区别：include指令会将外部文件原样输出，而parse指令会先对其进行解析再输出(即对外部文件中的vm语法解析)</p>
<pre><code class="language-velocity">#parse(&quot;header.vm&quot;)
#include(&quot;footer.vm&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pandas库loc和iloc]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/pandas-ku-loc-he-iloc/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/pandas-ku-loc-he-iloc/">
        </link>
        <updated>2020-10-19T14:59:34.000Z</updated>
        <content type="html"><![CDATA[<p>loc是指location的意思，iloc中的i是指integer</p>
<p>loc是根据index来索引。</p>
<p>iloc并不是根据index来索引，而是根据行号来索引，行号从0开始，逐次加1,并且只能用整数来取数。</p>
<h3 id="loc的使用">loc的使用</h3>
<p><strong>loc</strong>：loc的使用范围要远高于iloc, loc也能够做到iloc的切片取数, 除了df.loc[-1]</p>
<p><strong>使用情况</strong>：使用切片、索引、列名称查找，按条件(bool)查找</p>
<p><strong>数据源</strong>：</p>
<pre><code class="language-python">&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],
...      index=['A', 'B', 'C'],
...      columns=['col1', 'col2'])

          col1   col2
A          1       2
B          4       5
C          7       8
</code></pre>
<p><strong>用法示例</strong>：</p>
<p>（1）单独标签，返回一个单独的series</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['A']
col1  1
col2  2
</code></pre>
<p>（2）内嵌List，返回一个DataFrame</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['B','C']
          col1   col2
A          1       2
C          7       8
</code></pre>
<p>（3）Single label for row and column，注意，先索引，再列名</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['B','col2']
5
</code></pre>
<p>（4）多个索引加列名</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc['A':'C','col2']
A  2
C  8
</code></pre>
<p>（5）用布尔值：针对行进行过滤。False表示不取这一行。True表示取出这一行</p>
<pre><code class="language-PYTHON">&gt;&gt;&gt; df.loc[[FALSE,FALSE,TRUE]]
          col1   col2
C          7       8
</code></pre>
<p>（6）条件判断</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc[df['col1'] &gt; 6]
          col1   col2
C          7       8

&gt;&gt;&gt; df.loc[df['col1'] &gt; 6,['col1']]
          col1   
C          7      

&gt;&gt;&gt; df.loc[lambda df: df['col2'] == 8]
          col1   col2
C          7       8
</code></pre>
<p>7）设置值：选中某些值；整行；整列</p>
<pre><code class="language-python">&gt;&gt;&gt; df.loc[['A','B'],['col2']] == 20
          col1   col2
A          1       20
B          4       20
C          7       8

&gt;&gt;&gt; df.loc['C'] == 10
          col1   col2
A          1       20
B          4       20
C          10       10

&gt;&gt;&gt; df.loc[:,'col1'] == 30
          col1   col2
A          30       20
B          30       20
C          30       10
</code></pre>
<h3 id="iloc的使用">iloc的使用</h3>
<p><strong>iloc</strong>: i可以看着Integer,因此iloc就是用整数(Integer)来取数据的.</p>
<p><strong>使用情况</strong>：使用整数通过切片等方式取数</p>
<p><strong>用法示例</strong>：</p>
<pre><code class="language-python"># 切片
# 下面两种方法有同样的效果; 表示取出df中1：5行(不包括5)和3：6列
df.iloc[1:5,3:6] 
df.iloc[[1,2,3,4],[3,4,5]] 
# 另外 df.iloc[0]、df.iloc[1]、df.iloc[-1] 分别表示第一行、第二行、最后一行
# 同理df.iloc[:,0]、df.iloc[:,1]、df.iloc[:,-1] 分别表示第一列、第二列、最后一列
</code></pre>
<h3 id="总结">总结</h3>
<ul>
<li>loc使用范围比iloc更广更实用，loc可以使用切片、名称(index,columns)、也可以切片和名称混合使用；但是loc不能使用不存在的索引来充当切片取值,像-1。</li>
<li>iloc只能用整数来取数。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何解决failed to push some refs to git]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/ru-he-jie-jue-failed-to-push-some-refs-to-git/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/ru-he-jie-jue-failed-to-push-some-refs-to-git/">
        </link>
        <updated>2020-10-01T16:00:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="错误信息">错误信息</h3>
<p>在使用git 对源代码进行push到gitHub时可能会出错，例如</p>
<figure data-type="image" tabindex="1"><img src="https://zzddl.github.io/zdl.github.io//post-images/1601568150391.jpg" alt="" loading="lazy"></figure>
<h3 id="错误原因">错误原因</h3>
<p>出现错误的主要原因是github中的README.md文件不在本地代码目录中</p>
<h3 id="解决办法">解决办法</h3>
<p>执行命令<strong>git pull --rebase origin master</strong></p>
<p>**注：**pull=fetch+merge</p>
<p>执行代码后可以在本地看到README.md文件</p>
<p>此时再执行语句 git push -u origin master即可完成代码上传到github</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[STM32 位绑定操作]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/stm32-wei-bang-ding-cao-zuo/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/stm32-wei-bang-ding-cao-zuo/">
        </link>
        <updated>2020-09-08T02:13:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定义">定义</h3>
<p>STM32将寄存器映射到了位绑定区（bit_band region），这样就可以通过统一的线性寻址空间直接操作寄存器了，这个空间就是0x00000000~0xFFFF FFFF共4GB大小，除去寄存器外，其他包括程序存储区、数据存储区、输入输出端口等。</p>
<h3 id="支持位绑定操作的两个内存区">支持位绑定操作的两个内存区</h3>
<p>0x2000 0000~0x200F FFFF（SRAM区中最低1MB）</p>
<p>0x4000 0000~0x400F FFFF（片上外设区中最低1MB）</p>
<h3 id="位绑定操作的理解">位绑定操作的理解</h3>
<p>CPU是32位的，最方便快捷的是直接操作一个32位的地址，比如0x4200 ABCD这样，对这个地址赋值是最快捷的操作，只要一条指令。于是STM32又设计出别名区（Alias region）的概念，将一个32位地址空间对应到位带区（bit_band region）中的一个位。32位是STM32 CPU能独立访问的地址空间（称为字，即4个字节），将这个地址空间的起始位（bit0，其他bit1~bit31忽略）内容设为0或1就等于对位带区的相应位进行了操作，也相当于对寄存器进行了操作。</p>
<p>映射关系：</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20170214140941826" alt="img" loading="lazy"></figure>
<p>位绑定别名区一共有两个，每一个都是32MB，是位绑定区1MB的32倍，因为位绑定区是以位为单位，每8位有一个地址，位绑定别名区是以字为单位，一个字等于四个字节32位字长。</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20170214140948727" alt="img" loading="lazy"></figure>
<p>位绑定区0x2000 0000的第0位对应别名区地址0x22000000~0x2200 0003这4个字节，需要指出的是0x2200 0001、0x2200 0002、0x2200 0003这样的地址是不能直接被访问的，只有0x2200 0000、0x2200 0004、0x2200 0008…这样的起始地址（其实是4的倍数）才能被访问</p>
<p><strong>别名区的地址映射就是计算起始地址</strong></p>
<p>STM32别名区起始地址的计算：</p>
<p>it_word_addr = bit_band_base + (byte_offset * 32) +(bit_number * 4)</p>
<ul>
<li>bit_word_addr：是位绑定区目标位映射到别名区的字的起始地址</li>
<li>bit_band_base：是别名区的起始地址</li>
<li>byte_offset：是位带区包含目标位的字节的地址偏移量。</li>
<li>byte_offset * 32：是因为位带区的一个位要扩张到别名区的32个位，同样，一个位带区的地址也会扩张到别名区的32个地址。byte_offset * 32表示前面已经占用的地址。</li>
<li>bit_number：是目标位所在的位的位置（0-7）</li>
<li>bit_number*4是因为 1bit位要占用四个地址单元（四个字节，32 bit位）</li>
</ul>
<p>公式的变形：</p>
<p>it_word_addr = bit_band_base + ((byte_offset * 8) + bit_number) * 4</p>
<p>由于位绑定区每一个地址是8位，所以(byte_offset * 8)+ bit_number相当计算出了一个以字节为单位的偏移，再乘以4就是以字为单位的偏移了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大泥球（Big Ball of Mud）]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/da-ni-qiu-big-ball-of-mud/">
        </link>
        <updated>2020-09-01T07:35:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义：</h2>
<p>大泥球是指一个随意化的杂乱的结构化系统，只是代码的堆砌和拼凑，往往会导致很多错误或者缺陷。</p>
<h2 id="缺点">缺点：</h2>
<p>无法使得系统内的信息得到更好的控制和共享，使得信息失去了应有的价值。大泥球般的系统的整体结构没有得到很好的界定，也就使得大泥球越发的复杂和杂乱无章。最终会使得这个系统的代码不被程序员理解，更无法对其修复，无法满足用户的需求变化。</p>
<h2 id="产生的原因">产生的原因：</h2>
<p>首先，程序员在编写程序或是系统时遇到问题后的解决方法，往往不是合适的或者最优的解法，而是方便修改的，变动最小的，这就为以后的系统架构的混乱甚至整个系统的奔溃埋下了隐患。其次，用户的需求或者编程的要求是在不断地变化的，任何一个已有的系统都随之会产生重大的变化，使得系统越来越复杂化，维护也越来越昂贵，另外编写人员的变动等等因素都会导致系统的退化，一步步变为大泥球。</p>
<p>所以，可以将其产生的原因归结为：一次性代码，碎片式增长，缺少前期设计，应对需求和架构变化过晚，程序员的经验，技巧，眼界的限制。</p>
<h2 id="避免或者修改大泥球的方法">避免或者修改大泥球的方法：</h2>
<p>首先，程序员或者设计师为了在预算中并按时交付高质量的软件，就需要关注软件的特性和功能，然后集中在架构和性能，使得软件设计初步就避免产生小的问题或者方向的偏差。其次，程序员在编写软件时要及时的解决出现的小问题或者原型概念等等，这样不会使得问题堆积导致后期的无法修改。另外，应当及时处理用户需求的变化，由于需求往往会随着时间的推移而变化，所以应当逐步的解决，并且鼓励和积极面对变化而不是掩盖问题。另外，要保持一直工作的状态，不断地维护需求和系统。但不应当进行一次彻底的检查，这样很可能会破坏系统。当然，软件系统也是在变化的，但是不同的部分会以不同的速度变化，所以应当使得它们的变化率一致。最坏的结果就是代码已经下降到了无法修复甚至理解的地步，那么就扔掉，重新开始。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java核心类]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/java-he-xin-lei/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/java-he-xin-lei/">
        </link>
        <updated>2020-08-25T12:50:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java核心类">java核心类</h2>
<h3 id="字符串和编码">字符串和编码</h3>
<ol>
<li>
<p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code></p>
</li>
<li>
<p>Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池</p>
</li>
<li>
<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
</li>
<li>
<p><code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</p>
</li>
<li>
<p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p>
</li>
<li>
<p><code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>
</li>
<li>
<p><code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除。</p>
</li>
<li>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串</p>
</li>
<li>
<p>字符串中替换子串，有两种方法</p>
</li>
</ol>
<ul>
<li>根据字符或字符串替换</li>
</ul>
<pre><code class="language-java">String s = &quot;hello&quot;;
s.replace('l', 'w'); // &quot;hewwo&quot;，所有字符'l'被替换为'w'
s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;
</code></pre>
<ul>
<li>另一种是通过正则表达式替换：</li>
</ul>
<pre><code class="language-java">String s = &quot;A,,B;C ,D&quot;;
s.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;
</code></pre>
<ol start="10">
<li>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</li>
</ol>
<pre><code class="language-java">String s = &quot;A,B,C,D&quot;;
String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}
</code></pre>
<ol start="11">
<li>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</li>
</ol>
<pre><code class="language-java">String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};
String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot;
</code></pre>
<ol start="12">
<li>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String s = &quot;Hi %s, your score is %d!&quot;;
        System.out.println(s.formatted(&quot;Alice&quot;, 80));
        System.out.println(String.format(&quot;Hi %s, your score is %.2f!&quot;, &quot;Bob&quot;, 59.5));
    }
}
</code></pre>
<p>常用的占位符：</p>
<ul>
<li><code>%s</code>：显示字符串；</li>
<li><code>%d</code>：显示整数；</li>
<li><code>%x</code>：显示十六进制整数；</li>
<li><code>%f</code>：显示浮点数。</li>
</ul>
<ol start="13">
<li>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法：</li>
</ol>
<pre><code class="language-java">String.valueOf(123); // &quot;123&quot;
String.valueOf(45.67); // &quot;45.67&quot;
String.valueOf(true); // &quot;true&quot;
String.valueOf(new Object()); // 类似java.lang.Object@636be97c
</code></pre>
<ol start="14">
<li>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</li>
</ol>
<pre><code class="language-java">int n1 = Integer.parseInt(&quot;123&quot;); // 123
int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255
</code></pre>
<ol start="15">
<li>把字符串转换为<code>boolean</code>类型：</li>
</ol>
<pre><code class="language-java">boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false
</code></pre>
<ol start="16">
<li><code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</li>
</ol>
<pre><code class="language-java">Integer.getInteger(&quot;java.version&quot;); // 版本号，11
</code></pre>
<ol start="17">
<li><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</li>
</ol>
<pre><code class="language-java">char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]
String s = new String(cs); // char[] -&gt; String
</code></pre>
<ol start="18">
<li>
<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        char[] cs = &quot;Hello&quot;.toCharArray();
        String s = new String(cs);
        System.out.println(s);
        cs[0] = 'X';
        System.out.println(s);
    }
}
</code></pre>
<p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>
</li>
<li>
<p>UTF-8<code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为</code>UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>
</li>
</ol>
<pre><code class="language-java">byte[] b1 = &quot;Hello&quot;.getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换
byte[] b3 = &quot;Hello&quot;.getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
</code></pre>
<p>​		如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<pre><code class="language-java">byte[] b = ...
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
</code></pre>
<ol start="20">
<li>小结</li>
</ol>
<ul>
<li>Java字符串<code>String</code>是不可变对象；</li>
<li>字符串操作不改变原字符串内容，而是返回新字符串；</li>
<li>常用的字符串操作：提取子串、查找、替换、大小写转换等；</li>
<li>Java使用Unicode编码表示<code>String</code>和<code>char</code>；</li>
<li>转换编码就是将<code>String</code>和<code>byte[]</code>转换，需要指定编码；</li>
<li>转换为<code>byte[]</code>时，始终优先考虑<code>UTF-8</code>编码。</li>
</ul>
<h3 id="stringjoiner">StringJoiner</h3>
<p>用指定分隔符拼接字符串数组时，使用<code>StringJoiner</code>或者<code>String.join()</code>更方便；</p>
<p>用<code>StringJoiner</code>拼接字符串时，还可以额外附加一个“开头”和“结尾”。</p>
<h3 id="包装类型">包装类型</h3>
<p>1.Java的数据类型分两种：</p>
<ul>
<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li>
<li>引用类型：所有<code>class</code>和<code>interface</code>类型</li>
</ul>
<p><strong>引用类型</strong>可以赋值为<code>null</code>，表示空，但<strong>基本类型</strong>不能赋值为<code>null</code></p>
<p>2.想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p>
<pre><code class="language-java">public class Integer {
    private int value;

    public Integer(int value) {
        this.value = value;
    }

    public int intValue() {
        return this.value;
    }
}
</code></pre>
<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p>
<pre><code class="language-java">Integer n = null;
Integer n2 = new Integer(99);
int n3 = n2.intValue();
</code></pre>
<ol start="3">
<li></li>
</ol>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int i = 100;
        // 通过new操作符创建Integer实例(不推荐使用,会有编译警告):
        Integer n1 = new Integer(i);
        // 通过静态方法valueOf(int)创建Integer实例:
        Integer n2 = Integer.valueOf(i);
        // 通过静态方法valueOf(String)创建Integer实例:
        Integer n3 = Integer.valueOf(&quot;100&quot;);
        System.out.println(n3.intValue());
    }
}
</code></pre>
<p>运行结果：</p>
<p>Note: Main.java uses or overrides a deprecated API.<br>
Note: Recompile with -Xlint:deprecation for details.<br>
100</p>
<p>4.Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<pre><code class="language-java">Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()
</code></pre>
<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing）</p>
<p>把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）</p>
<p>5.<code>Integer</code>对象是不变的。</p>
<p>6.<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较</p>
<p>7.<code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制
        System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制
        System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制
        System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制
        System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制
    }
}
</code></pre>
<p>8.所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<pre><code class="language-java">// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();
</code></pre>
<p>9.小结</p>
<ul>
<li>Java核心库提供的包装类型可以把基本类型包装为<code>class</code>；</li>
<li>自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；</li>
<li>装箱和拆箱会影响执行效率，且拆箱时可能发生<code>NullPointerException</code>；</li>
<li>包装类型的比较必须使用<code>equals()</code>；</li>
<li>整数和浮点数的包装类型都继承自<code>Number</code>；</li>
<li>包装类型提供了大量实用方法。</li>
</ul>
<h3 id="javabean">JavaBean</h3>
<p>1.如果读写方法符合以下这种命名规范：</p>
<pre><code class="language-java">// 读方法:
public Type getXyz()
// 写方法:
public void setXyz(Type value)
</code></pre>
<p>那么这种<code>class</code>被称为<code>JavaBean</code></p>
<p>2.<code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<pre><code class="language-java">// 读方法:
public boolean isChild()
// 写方法:
public void setChild(boolean value)
</code></pre>
<p>3.小结</p>
<ul>
<li>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</li>
<li>属性是一种通用的叫法，并非Java语法规定；</li>
<li>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</li>
<li>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</li>
</ul>
<h3 id="枚举类">枚举类</h3>
<p>1.enum</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println(&quot;Work at home!&quot;);
        } else {
            System.out.println(&quot;Work at office!&quot;);
        }
    }
}

enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
</code></pre>
<p>2.不同类型的枚举不能互相比较或者赋值，因为类型不符</p>
<p>3.<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点:</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>
</ul>
<p>4.返回常量名，例如：</p>
<pre><code class="language-java">String s = Weekday.SUN.name(); // &quot;SUN&quot;
</code></pre>
<p>5.返回定义的常量的顺序，从0开始计数，例如：</p>
<pre><code class="language-java">int n = Weekday.MON.ordinal(); // 1
</code></pre>
<p>6.默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法</p>
<p>7.枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中, 加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p>
<p>8.小结</p>
<ul>
<li>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum { … }</code>；</li>
<li>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</li>
<li>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</li>
<li>可以为<code>enum</code>编写构造方法、字段和方法</li>
<li><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</li>
<li><code>enum</code>适合用在<code>switch</code>语句中。</li>
</ul>
<h3 id="记录类">记录类</h3>
<p>1.使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>
<ul>
<li>定义class时使用<code>final</code>，无法派生子类；</li>
<li>​	 每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>
</ul>
<p>2.小结</p>
<p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p>
<ul>
<li>使用<code>record</code>定义的是不变类；</li>
<li>可以编写Compact Constructor对参数进行验证；</li>
<li>可以定义静态方法。</li>
</ul>
<h3 id="biginteger">BigInteger</h3>
<p><code>BigInteger</code>用于表示任意大小的整数；</p>
<p><code>BigInteger</code>是不变类，并且继承自<code>Number</code>；</p>
<p>将<code>BigInteger</code>转换成基本类型时可使用<code>longValueExact()</code>等方法保证结果准确。</p>
<h3 id="bigdecimal">BigDecimal</h3>
<p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<p>1.<code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.45&quot;);
BigDecimal d2 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
System.out.println(d1.scale()); // 2,两位小数
System.out.println(d2.scale()); // 4
System.out.println(d3.scale()); // 0
</code></pre>
<p>2.通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code></p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.4500&quot;);
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00

BigDecimal d3 = new BigDecimal(&quot;1234500&quot;);
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2
</code></pre>
<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>
<p>3.可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BigDecimal d1 = new BigDecimal(&quot;123.456789&quot;);
        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567
        System.out.println(d2);
        System.out.println(d3);
    }
}

</code></pre>
<p>做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断</p>
<pre><code class="language-java">BigDecimal d1 = new BigDecimal(&quot;123.456&quot;);
BigDecimal d2 = new BigDecimal(&quot;23.456789&quot;);
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽
</code></pre>
<p>4.还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        BigDecimal n = new BigDecimal(&quot;12.345&quot;);
        BigDecimal m = new BigDecimal(&quot;0.12&quot;);
        BigDecimal[] dr = n.divideAndRemainder(m);
        System.out.println(dr[0]); // 102
        System.out.println(dr[1]); // 0.105
    }
}
</code></pre>
<p>5.比较BigDecimal</p>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<p>6.<code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>
<p>7.小结</p>
<p><code>BigDecimal</code>用于表示精确的小数，常用于财务计算；</p>
<p>比较<code>BigDecimal</code>的值是否相等，必须使用<code>compareTo()</code>而不能使用<code>equals()</code>。</p>
<h3 id="常用工具类">常用工具类</h3>
<h4 id="math">Math</h4>
<p>1.求绝对值：</p>
<pre><code class="language-java">Math.abs(-100); // 100
Math.abs(-7.8); // 7.8
</code></pre>
<p>2.最大、最小值</p>
<pre><code class="language-java">Math.max(100, 99); // 100
Math.min(1.2, 2.3); // 1.2
</code></pre>
<p>3.计算x的y次方</p>
<pre><code class="language-java">Math.pow(2, 10); // 2的10次方=1024
</code></pre>
<p>4.x开平方</p>
<pre><code class="language-java">Math.sqrt(2); // 1.414...
</code></pre>
<p>5.计算e的x次方</p>
<pre><code class="language-java">Math.exp(2); // 7.389...
</code></pre>
<p>6.计算以e为底的对数</p>
<pre><code class="language-java">Math.log(4); // 1.386...
</code></pre>
<p>7.计算以10为底的对数：</p>
<pre><code class="language-java">Math.log10(100); // 2
</code></pre>
<p>8.三角函数：</p>
<pre><code class="language-java">Math.sin(3.14); // 0.00159...
Math.cos(3.14); // -0.9999...
Math.tan(3.14); // -0.0015...
Math.asin(1.0); // 1.57079...
Math.acos(1.0); // 0.0
</code></pre>
<p>9.几个常量：</p>
<pre><code class="language-java">double pi = Math.PI; // 3.14159...
double e = Math.E; // 2.7182818...
Math.sin(Math.PI / 6); // sin(π/6) = 0.5
</code></pre>
<h4 id="random">Random</h4>
<p>1.<code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<pre><code class="language-java">Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
</code></pre>
<p>创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</p>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Random r = new Random(12345);
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(r.nextInt(100));
        }
        // 51, 80, 41, 28, 55...
    }
}
</code></pre>
<h4 id="securerandom">SecureRandom</h4>
<p>1.<code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<pre><code class="language-java">SecureRandom sr = new SecureRandom();
System.out.println(sr.nextInt(100));
</code></pre>
<p>2.<code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
        } catch (NoSuchAlgorithmException e) {
            sr = new SecureRandom(); // 获取普通的安全随机数生成器
        }
        byte[] buffer = new byte[16];
        sr.nextBytes(buffer); // 用安全随机数填充buffer
        System.out.println(Arrays.toString(buffer));
    }
}
</code></pre>
<p>3.<code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- HTML5 SSE]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-sse/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-sse/">
        </link>
        <updated>2020-08-19T02:54:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Server-Sent 事件允许网页从服务器获得更新。</strong></p>
<h3 id="接收-server-sent-事件通知">接收 Server-Sent 事件通知</h3>
<p>EventSource 对象用于接收服务器发送事件通知：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;获得服务器更新&lt;/h1&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;

&lt;script&gt;
if(typeof(EventSource)!==&quot;undefined&quot;)
  {
  var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;);
  source.onmessage=function(event)
    {
    document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
    };
  }
else
  {
  document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;;
  }
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>解释：</p>
<ul>
<li>创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 &quot;demo_sse.php&quot;）</li>
<li>每当接收到一次更新，就会发生 onmessage 事件</li>
<li>当 onmessage 事件发生时，把已接收的数据推入 id 为 &quot;result&quot; 的元素中</li>
</ul>
<h3 id="检测-server-sent-事件支持">检测 Server-Sent 事件支持</h3>
<pre><code class="language-html">if(typeof(EventSource) !== &quot;undefined&quot;) {
    // 是的！支持服务器发送事件！
    // 一些代码.....
} else {
    // 抱歉！不支持服务器发送事件！
}
</code></pre>
<h3 id="eventsource-对象">EventSource 对象</h3>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onopen</td>
<td style="text-align:left">当通往服务器的连接被打开</td>
</tr>
<tr>
<td style="text-align:left">onmessage</td>
<td style="text-align:left">当接收到消息</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:left">当发生错误</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[html学习8.19 -- HTML5 web workers]]></title>
        <id>https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-web-workers/</id>
        <link href="https://zzddl.github.io/zdl.github.io/post/html-xue-xi-819-html5-web-workers/">
        </link>
        <updated>2020-08-19T02:49:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="web-worker">Web Worker</h3>
<p>当在 HTML 页面中执行脚本时，页面是不可响应的，直到脚本已完成。</p>
<p>Web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能</p>
<h3 id="检测-web-worker-支持">检测 Web Worker 支持</h3>
<pre><code class="language-html">if (typeof(Worker) !== &quot;undefined&quot;) {
    // 是的！支持 Web worker！
    // 一些代码.....
} else {
    // 抱歉！不支持 Web Worker！
}
</code></pre>
<h3 id="创建-web-worker-文件">创建 Web Worker 文件</h3>
<p>让我们在一个外部 JavaScript 文件中创建我们的 web worker。</p>
<p>创建计数脚本。该脚本存储于 &quot;demo_workers.js&quot; 文件中：</p>
<pre><code class="language-html">var i = 0;

function timedCount() {
    i = i + 1;
    postMessage(i);
    setTimeout(&quot;timedCount()&quot;,500);
}

timedCount();
</code></pre>
<p>以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</p>
<h3 id="创建-web-worker-对象">创建 Web Worker 对象</h3>
<p>已经有 web worker 文件，需要从 HTML 页面调用它。</p>
<p>检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 &quot;demo_workers.js&quot; 中的代码：</p>
<pre><code class="language-html">if (typeof(w) == &quot;undefined&quot;) {
    w = new Worker(&quot;demo_workers.js&quot;);
}
</code></pre>
<p>然后我们就可以从 web worker 发生和接收消息了。</p>
<p>向 web worker 添加一个 &quot;onmessage&quot; 事件监听器：</p>
<pre><code class="language-html">w.onmessage = function(event){
    document.getElementById(&quot;result&quot;).innerHTML = event.data;
};
</code></pre>
<p>当 web worker 传送消息时，会执行事件监听器中的代码。来自 web worker 的数据会存储于 event.data 中。</p>
<h3 id="终止-web-worker">终止 Web Worker</h3>
<p>当创建 web worker 后，它会继续监听消息（即使在外部脚本完成后）直到其被终止为止。</p>
<p>终止并且释放资源，使用 terminate() 方法：</p>
<pre><code class="language-html">w.terminate();
</code></pre>
<h3 id="复用-web-worker">复用 Web Worker</h3>
<p>把 worker 变量设置为 undefined，在其被终止后，可以重复使用该代码：</p>
<pre><code class="language-html">w = undefined;
</code></pre>
<h3 id="完整的-web-worker-实例代码">完整的 Web Worker 实例代码</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;
&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt; 
&lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;
&lt;br&gt;&lt;br&gt;

&lt;script&gt;
var w;

function startWorker() {
    if(typeof(Worker) !== &quot;undefined&quot;) {
        if(typeof(w) == &quot;undefined&quot;) {
            w = new Worker(&quot;demo_workers.js&quot;);
        }
        w.onmessage = function(event) {
            document.getElementById(&quot;result&quot;).innerHTML = event.data;
        };
    } else {
        document.getElementById(&quot;result&quot;).innerHTML = &quot;Sorry! No Web Worker support.&quot;;
    }
}

function stopWorker() { 
    w.terminate();
    w = undefined;
}
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="web-worker-和-dom">Web Worker 和 DOM</h3>
<p>由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：</p>
<ul>
<li>window 对象</li>
<li>document 对象</li>
<li>parent 对象</li>
</ul>
]]></content>
    </entry>
</feed>